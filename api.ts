/* tslint:disable */
/* eslint-disable */
/**
 * Gallop API
 * Data and insights APIs, webooks, and dashboards enabling businesses to launch tokenized products in seconds.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@higallop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface GetEthCollectionFloorPriceOHLCRequest
 */
export interface GetEthCollectionFloorPriceOHLCRequest {
    /**
     * The Ethereum contract address to identify the collection.
     * @type {string}
     * @memberof GetEthCollectionFloorPriceOHLCRequest
     */
    'collection_address': string;
    /**
     * The interval at which to return OHLC, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthCollectionFloorPriceOHLCRequest
     */
    'frequency'?: string;
    /**
     * An attribute of the NFT to group results by.
     * @type {string}
     * @memberof GetEthCollectionFloorPriceOHLCRequest
     */
    'group_by'?: string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionFloorPriceOHLCRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionFloorPriceOHLCRequest
     */
    'end_date'?: string;
}
/**
 * 
 * @export
 * @interface GetEthCollectionForecastsRequest
 */
export interface GetEthCollectionForecastsRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'collection_address': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetEthCollectionForecastsRequest
     */
    'percentiles'?: Array<number>;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. `arc` for ARCH
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'voltype'?: GetEthCollectionForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetEthCollectionForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for.
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'dist'?: GetEthCollectionForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to true, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetEthCollectionForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetEthCollectionForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCollectionForecastsRequest
     */
    'rept_curr'?: GetEthCollectionForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCollectionForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetEthCollectionForecastsRequestArchParams}
     * @memberof GetEthCollectionForecastsRequest
     */
    'arch_params'?: GetEthCollectionForecastsRequestArchParams;
}

export const GetEthCollectionForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetEthCollectionForecastsRequestVoltypeEnum = typeof GetEthCollectionForecastsRequestVoltypeEnum[keyof typeof GetEthCollectionForecastsRequestVoltypeEnum];
export const GetEthCollectionForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCollectionForecastsRequestDistEnum = typeof GetEthCollectionForecastsRequestDistEnum[keyof typeof GetEthCollectionForecastsRequestDistEnum];
export const GetEthCollectionForecastsRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCollectionForecastsRequestReptCurrEnum = typeof GetEthCollectionForecastsRequestReptCurrEnum[keyof typeof GetEthCollectionForecastsRequestReptCurrEnum];

/**
 * JSON containing options for the ARCH family model.
 * @export
 * @interface GetEthCollectionForecastsRequestArchParams
 */
export interface GetEthCollectionForecastsRequestArchParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... . 
     * @type {string}
     * @memberof GetEthCollectionForecastsRequestArchParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetEthCollectionForecastsRequestArchParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetEthCollectionForecastsRequestArchParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {number}
     * @memberof GetEthCollectionForecastsRequestArchParams
     */
    'p'?: number;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetEthCollectionForecastsRequestArchParams
     */
    'dist'?: GetEthCollectionForecastsRequestArchParamsDistEnum;
}

export const GetEthCollectionForecastsRequestArchParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCollectionForecastsRequestArchParamsDistEnum = typeof GetEthCollectionForecastsRequestArchParamsDistEnum[keyof typeof GetEthCollectionForecastsRequestArchParamsDistEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionListingsOHLCRequest
 */
export interface GetEthCollectionListingsOHLCRequest {
    /**
     * The Ethereum contract address to identify the collection.
     * @type {string}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'collection_address': string;
    /**
     * If `true`, report only historical floor prices. Otherwise, report OHFC candlesticks, number of active listings, number of unique owners and the average age of open listings.
     * @type {boolean}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'floor_only'?: boolean;
    /**
     * The interval at which to return Floor prices / OHLF, e.g. `1D` for daily, `1M` for monthly etc. Must be >= `6H`
     * @type {string}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'rept_curr'?: GetEthCollectionListingsOHLCRequestReptCurrEnum;
    /**
     * The ISO 8601 start date/datetime to return results for
     * @type {string}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'report_start_date'?: string;
    /**
     * The ISO 8601 end date/datetime to return results for
     * @type {string}
     * @memberof GetEthCollectionListingsOHLCRequest
     */
    'report_end_date'?: string;
}

export const GetEthCollectionListingsOHLCRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCollectionListingsOHLCRequestReptCurrEnum = typeof GetEthCollectionListingsOHLCRequestReptCurrEnum[keyof typeof GetEthCollectionListingsOHLCRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionOwnersRequest
 */
export interface GetEthCollectionOwnersRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetEthCollectionOwnersRequest
     */
    'collection_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthCollectionOwnersRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthCollectionOwnersRequest
     */
    'page_size'?: GetEthCollectionOwnersRequestPageSizeEnum;
}

export const GetEthCollectionOwnersRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthCollectionOwnersRequestPageSizeEnum = typeof GetEthCollectionOwnersRequestPageSizeEnum[keyof typeof GetEthCollectionOwnersRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionPriceDiffRequest
 */
export interface GetEthCollectionPriceDiffRequest {
    /**
     * The Ethereum contract address to identify the collection.
     * @type {string}
     * @memberof GetEthCollectionPriceDiffRequest
     */
    'collection_address': string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionPriceDiffRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionPriceDiffRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCollectionPriceDiffRequest
     */
    'exclude_wash'?: boolean;
}
/**
 * 
 * @export
 * @interface GetEthCollectionSalesOHLCRequest
 */
export interface GetEthCollectionSalesOHLCRequest {
    /**
     * The Ethereum contract address to identify the collection.
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'collection_address': string;
    /**
     * The interval at which to return OHLC, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'frequency'?: string;
    /**
     * An attribute of the NFT to group results by.
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'group_by'?: string;
    /**
     * If \'true\', response dicts contain OHLCV
     * @type {boolean}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'volume'?: boolean;
    /**
     * If \'true\', append number of trades to OHLC(V)
     * @type {boolean}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'n_trades'?: boolean;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'rept_curr'?: GetEthCollectionSalesOHLCRequestReptCurrEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCollectionSalesOHLCRequest
     */
    'exclude_wash'?: boolean;
}

export const GetEthCollectionSalesOHLCRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCollectionSalesOHLCRequestReptCurrEnum = typeof GetEthCollectionSalesOHLCRequestReptCurrEnum[keyof typeof GetEthCollectionSalesOHLCRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionSummaryRequest
 */
export interface GetEthCollectionSummaryRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetEthCollectionSummaryRequest
     */
    'collection_address': string;
    /**
     * An attribute of the NFT.
     * @type {string}
     * @memberof GetEthCollectionSummaryRequest
     */
    'group_by'?: string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCollectionSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCollectionSummaryRequest
     */
    'rept_curr'?: GetEthCollectionSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCollectionSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetEthCollectionSummaryRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCollectionSummaryRequestReptCurrEnum = typeof GetEthCollectionSummaryRequestReptCurrEnum[keyof typeof GetEthCollectionSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionTransactionsRequest
 */
export interface GetEthCollectionTransactionsRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'collection_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'page_size'?: GetEthCollectionTransactionsRequestPageSizeEnum;
    /**
     * The oldest block number to return.
     * @type {number}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'start_block_number'?: number;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetEthCollectionTransactionsRequest
     */
    'end_date'?: string;
}

export const GetEthCollectionTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthCollectionTransactionsRequestPageSizeEnum = typeof GetEthCollectionTransactionsRequestPageSizeEnum[keyof typeof GetEthCollectionTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthCollectionsRequest
 */
export interface GetEthCollectionsRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthCollectionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthCollectionsRequest
     */
    'page_size'?: GetEthCollectionsRequestPageSizeEnum;
    /**
     * The name of the collection searched.
     * @type {string}
     * @memberof GetEthCollectionsRequest
     */
    'collection_name'?: string;
    /**
     * Only return collections that have traded.
     * @type {boolean}
     * @memberof GetEthCollectionsRequest
     */
    'traded'?: boolean;
    /**
     * Only return collections recorded after this day [YYYY-MM-DD]
     * @type {string}
     * @memberof GetEthCollectionsRequest
     */
    'created_after'?: string;
    /**
     * The value to sort by. Defaults to created_at
     * @type {string}
     * @memberof GetEthCollectionsRequest
     */
    'sort_by'?: GetEthCollectionsRequestSortByEnum;
}

export const GetEthCollectionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthCollectionsRequestPageSizeEnum = typeof GetEthCollectionsRequestPageSizeEnum[keyof typeof GetEthCollectionsRequestPageSizeEnum];
export const GetEthCollectionsRequestSortByEnum = {
    CreatedAt: 'created_at',
    CollectionName: 'collection_name'
} as const;

export type GetEthCollectionsRequestSortByEnum = typeof GetEthCollectionsRequestSortByEnum[keyof typeof GetEthCollectionsRequestSortByEnum];

/**
 * 
 * @export
 * @interface GetEthCustomCollectionRiskRequest
 */
export interface GetEthCustomCollectionRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'collection_address': string;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'percentiles'?: Array<number>;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'dist'?: GetEthCustomCollectionRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'end_date'?: string;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'rept_curr'?: GetEthCustomCollectionRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetEthCustomCollectionRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetEthCustomCollectionRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCustomCollectionRiskRequestDistEnum = typeof GetEthCustomCollectionRiskRequestDistEnum[keyof typeof GetEthCustomCollectionRiskRequestDistEnum];
export const GetEthCustomCollectionRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCustomCollectionRiskRequestReptCurrEnum = typeof GetEthCustomCollectionRiskRequestReptCurrEnum[keyof typeof GetEthCustomCollectionRiskRequestReptCurrEnum];

/**
 * JSON containing options for the ARCH model.
 * @export
 * @interface GetEthCustomCollectionRiskRequestArcParams
 */
export interface GetEthCustomCollectionRiskRequestArcParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... .
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestArcParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestArcParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestArcParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestArcParams
     */
    'p'?: number;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestArcParams
     */
    'dist'?: GetEthCustomCollectionRiskRequestArcParamsDistEnum;
}

export const GetEthCustomCollectionRiskRequestArcParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCustomCollectionRiskRequestArcParamsDistEnum = typeof GetEthCustomCollectionRiskRequestArcParamsDistEnum[keyof typeof GetEthCustomCollectionRiskRequestArcParamsDistEnum];

/**
 * JSON containing options for the GARCH model.
 * @export
 * @interface GetEthCustomCollectionRiskRequestGarParams
 */
export interface GetEthCustomCollectionRiskRequestGarParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... .
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestGarParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestGarParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestGarParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestGarParams
     */
    'p'?: number;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestGarParams
     */
    'dist'?: GetEthCustomCollectionRiskRequestGarParamsDistEnum;
}

export const GetEthCustomCollectionRiskRequestGarParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCustomCollectionRiskRequestGarParamsDistEnum = typeof GetEthCustomCollectionRiskRequestGarParamsDistEnum[keyof typeof GetEthCustomCollectionRiskRequestGarParamsDistEnum];

/**
 * JSON containing options for the HARCH model.
 * @export
 * @interface GetEthCustomCollectionRiskRequestHarParams
 */
export interface GetEthCustomCollectionRiskRequestHarParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... .
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {Array<number>}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'p'?: Array<number>;
    /**
     * Order of the lagged (transformed) conditional variance.
     * @type {number}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'q'?: number;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetEthCustomCollectionRiskRequestHarParams
     */
    'dist'?: GetEthCustomCollectionRiskRequestHarParamsDistEnum;
}

export const GetEthCustomCollectionRiskRequestHarParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCustomCollectionRiskRequestHarParamsDistEnum = typeof GetEthCustomCollectionRiskRequestHarParamsDistEnum[keyof typeof GetEthCustomCollectionRiskRequestHarParamsDistEnum];

/**
 * 
 * @export
 * @interface GetEthCustomTokenRiskRequest
 */
export interface GetEthCustomTokenRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'token_id': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'holding_period': string;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'dist'?: GetEthCustomTokenRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'end_date'?: string;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'rept_curr'?: GetEthCustomTokenRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetEthCustomTokenRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetEthCustomTokenRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthCustomTokenRiskRequestDistEnum = typeof GetEthCustomTokenRiskRequestDistEnum[keyof typeof GetEthCustomTokenRiskRequestDistEnum];
export const GetEthCustomTokenRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthCustomTokenRiskRequestReptCurrEnum = typeof GetEthCustomTokenRiskRequestReptCurrEnum[keyof typeof GetEthCustomTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthDefaultCollectionRiskRequest
 */
export interface GetEthDefaultCollectionRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthDefaultCollectionRiskRequest
     */
    'collection_address': string;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetEthDefaultCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthDefaultCollectionRiskRequest
     */
    'rept_curr'?: GetEthDefaultCollectionRiskRequestReptCurrEnum;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetEthDefaultCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetEthDefaultCollectionRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetEthDefaultCollectionRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthDefaultCollectionRiskRequestReptCurrEnum = typeof GetEthDefaultCollectionRiskRequestReptCurrEnum[keyof typeof GetEthDefaultCollectionRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthDefaultTokenRiskRequest
 */
export interface GetEthDefaultTokenRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthDefaultTokenRiskRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetEthDefaultTokenRiskRequest
     */
    'token_id': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetEthDefaultTokenRiskRequest
     */
    'holding_period': string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthDefaultTokenRiskRequest
     */
    'rept_curr'?: GetEthDefaultTokenRiskRequestReptCurrEnum;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetEthDefaultTokenRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetEthDefaultTokenRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthDefaultTokenRiskRequestReptCurrEnum = typeof GetEthDefaultTokenRiskRequestReptCurrEnum[keyof typeof GetEthDefaultTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthEnsLookupRequest
 */
export interface GetEthEnsLookupRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthEnsLookupRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthEnsLookupRequest
     */
    'page_size'?: GetEthEnsLookupRequestPageSizeEnum;
    /**
     * The wallet address to query.
     * @type {string}
     * @memberof GetEthEnsLookupRequest
     */
    'wallet_address'?: string;
    /**
     * The name to query.
     * @type {string}
     * @memberof GetEthEnsLookupRequest
     */
    'name'?: string;
}

export const GetEthEnsLookupRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthEnsLookupRequestPageSizeEnum = typeof GetEthEnsLookupRequestPageSizeEnum[keyof typeof GetEthEnsLookupRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthHistoricalEventsRequest
 */
export interface GetEthHistoricalEventsRequest {
    /**
     * The contract address of a collection.
     * @type {string}
     * @memberof GetEthHistoricalEventsRequest
     */
    'collection_address': string;
    /**
     * The id for the token.
     * @type {string}
     * @memberof GetEthHistoricalEventsRequest
     */
    'token_id'?: string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthHistoricalEventsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthHistoricalEventsRequest
     */
    'page_size'?: GetEthHistoricalEventsRequestPageSizeEnum;
    /**
     * The type of event: list, transfer, offer, mint, sale, cancel_list or cancel_offer
     * @type {string}
     * @memberof GetEthHistoricalEventsRequest
     */
    'event_type'?: GetEthHistoricalEventsRequestEventTypeEnum;
}

export const GetEthHistoricalEventsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthHistoricalEventsRequestPageSizeEnum = typeof GetEthHistoricalEventsRequestPageSizeEnum[keyof typeof GetEthHistoricalEventsRequestPageSizeEnum];
export const GetEthHistoricalEventsRequestEventTypeEnum = {
    List: 'list',
    Transfer: 'transfer',
    Offer: 'offer',
    Mint: 'mint',
    Sale: 'sale',
    CancelList: 'cancel_list',
    CancelOffer: 'cancel_offer'
} as const;

export type GetEthHistoricalEventsRequestEventTypeEnum = typeof GetEthHistoricalEventsRequestEventTypeEnum[keyof typeof GetEthHistoricalEventsRequestEventTypeEnum];

/**
 * 
 * @export
 * @interface GetEthHistoricalTransactionsRequest
 */
export interface GetEthHistoricalTransactionsRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetEthHistoricalTransactionsRequest
     */
    'collection_address': string;
    /**
     * The id for the token.
     * @type {string}
     * @memberof GetEthHistoricalTransactionsRequest
     */
    'token_id'?: string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthHistoricalTransactionsRequest
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface GetEthLeaderBoardRequest
 */
export interface GetEthLeaderBoardRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthLeaderBoardRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthLeaderBoardRequest
     */
    'page_size'?: GetEthLeaderBoardRequestPageSizeEnum;
    /**
     * The requested time interval
     * @type {string}
     * @memberof GetEthLeaderBoardRequest
     */
    'interval': GetEthLeaderBoardRequestIntervalEnum;
    /**
     * The requested calculation metric
     * @type {string}
     * @memberof GetEthLeaderBoardRequest
     */
    'ranking_metric': GetEthLeaderBoardRequestRankingMetricEnum;
}

export const GetEthLeaderBoardRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthLeaderBoardRequestPageSizeEnum = typeof GetEthLeaderBoardRequestPageSizeEnum[keyof typeof GetEthLeaderBoardRequestPageSizeEnum];
export const GetEthLeaderBoardRequestIntervalEnum = {
    OneDay: 'one_day',
    SevenDays: 'seven_days',
    ThirtyDays: 'thirty_days',
    NinetyDays: 'ninety_days',
    AllTime: 'all_time'
} as const;

export type GetEthLeaderBoardRequestIntervalEnum = typeof GetEthLeaderBoardRequestIntervalEnum[keyof typeof GetEthLeaderBoardRequestIntervalEnum];
export const GetEthLeaderBoardRequestRankingMetricEnum = {
    EthVolume: 'eth_volume',
    SalesCount: 'sales_count'
} as const;

export type GetEthLeaderBoardRequestRankingMetricEnum = typeof GetEthLeaderBoardRequestRankingMetricEnum[keyof typeof GetEthLeaderBoardRequestRankingMetricEnum];

/**
 * 
 * @export
 * @interface GetEthMarketplaceDataRequest
 */
export interface GetEthMarketplaceDataRequest {
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetEthMarketplaceDataRequest
     */
    'collection_address': Array<string>;
    /**
     * Array of sub collections (e.g. Art Blocks)
     * @type {Array<string>}
     * @memberof GetEthMarketplaceDataRequest
     */
    'sub_collection_tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetEthMarketplaceFloorPriceRequest
 */
export interface GetEthMarketplaceFloorPriceRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthMarketplaceFloorPriceRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthMarketplaceFloorPriceRequest
     */
    'page_size'?: GetEthMarketplaceFloorPriceRequestPageSizeEnum;
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetEthMarketplaceFloorPriceRequest
     */
    'collection_address'?: Array<string>;
}

export const GetEthMarketplaceFloorPriceRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthMarketplaceFloorPriceRequestPageSizeEnum = typeof GetEthMarketplaceFloorPriceRequestPageSizeEnum[keyof typeof GetEthMarketplaceFloorPriceRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthMarketplaceTraitDataRequest
 */
export interface GetEthMarketplaceTraitDataRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetEthMarketplaceTraitDataRequest
     */
    'collection_address': string;
}
/**
 * 
 * @export
 * @interface GetEthRarityRequest
 */
export interface GetEthRarityRequest {
    /**
     * The Ethereum contract address to identify the collection.
     * @type {string}
     * @memberof GetEthRarityRequest
     */
    'collection_address': string;
    /**
     * Dict containing trait keys and weight values.
     * @type {object}
     * @memberof GetEthRarityRequest
     */
    'weights'?: object;
    /**
     * An array of token ids.
     * @type {Array<string>}
     * @memberof GetEthRarityRequest
     */
    'token_id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetEthTokenAppraisalRequest
 */
export interface GetEthTokenAppraisalRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthTokenAppraisalRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetEthTokenAppraisalRequest
     */
    'token_id': Array<string>;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthTokenAppraisalRequest
     */
    'rept_curr'?: GetEthTokenAppraisalRequestReptCurrEnum;
    /**
     * The interval at which to calculate intermediate results and forecasts.
     * @type {string}
     * @memberof GetEthTokenAppraisalRequest
     */
    'frequency'?: string;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out). Defaults to zero which only returns nowcasts.
     * @type {number}
     * @memberof GetEthTokenAppraisalRequest
     */
    'horizon'?: number;
    /**
     * The significance level for the liquidation estimate, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetEthTokenAppraisalRequest
     */
    'alpha'?: number;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthTokenAppraisalRequest
     */
    'exclude_wash'?: boolean;
}

export const GetEthTokenAppraisalRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthTokenAppraisalRequestReptCurrEnum = typeof GetEthTokenAppraisalRequestReptCurrEnum[keyof typeof GetEthTokenAppraisalRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthTokenForecastsRequest
 */
export interface GetEthTokenForecastsRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetEthTokenForecastsRequest
     */
    'token_id': Array<string>;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. `arc` for ARCH
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'voltype'?: GetEthTokenForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetEthTokenForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for.
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'dist'?: GetEthTokenForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to True, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetEthTokenForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetEthTokenForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthTokenForecastsRequest
     */
    'rept_curr'?: GetEthTokenForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthTokenForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetEthCollectionForecastsRequestArchParams}
     * @memberof GetEthTokenForecastsRequest
     */
    'arch_params'?: GetEthCollectionForecastsRequestArchParams;
}

export const GetEthTokenForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetEthTokenForecastsRequestVoltypeEnum = typeof GetEthTokenForecastsRequestVoltypeEnum[keyof typeof GetEthTokenForecastsRequestVoltypeEnum];
export const GetEthTokenForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetEthTokenForecastsRequestDistEnum = typeof GetEthTokenForecastsRequestDistEnum[keyof typeof GetEthTokenForecastsRequestDistEnum];
export const GetEthTokenForecastsRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthTokenForecastsRequestReptCurrEnum = typeof GetEthTokenForecastsRequestReptCurrEnum[keyof typeof GetEthTokenForecastsRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthTokenSummaryRequest
 */
export interface GetEthTokenSummaryRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthTokenSummaryRequest
     */
    'collection_address': string;
    /**
     * The id for the token.
     * @type {Array<string>}
     * @memberof GetEthTokenSummaryRequest
     */
    'token_id': Array<string>;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetEthTokenSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetEthTokenSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetEthTokenSummaryRequest
     */
    'rept_curr'?: GetEthTokenSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetEthTokenSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetEthTokenSummaryRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd'
} as const;

export type GetEthTokenSummaryRequestReptCurrEnum = typeof GetEthTokenSummaryRequestReptCurrEnum[keyof typeof GetEthTokenSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetEthTokenTransactionsRequest
 */
export interface GetEthTokenTransactionsRequest {
    /**
     * The contract address the token belongs to.
     * @type {string}
     * @memberof GetEthTokenTransactionsRequest
     */
    'collection_address': string;
    /**
     * The token id.
     * @type {string}
     * @memberof GetEthTokenTransactionsRequest
     */
    'token_id': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthTokenTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthTokenTransactionsRequest
     */
    'page_size'?: GetEthTokenTransactionsRequestPageSizeEnum;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetEthTokenTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The oldest block number to return.
     * @type {number}
     * @memberof GetEthTokenTransactionsRequest
     */
    'start_block_number'?: number;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetEthTokenTransactionsRequest
     */
    'end_date'?: string;
}

export const GetEthTokenTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthTokenTransactionsRequestPageSizeEnum = typeof GetEthTokenTransactionsRequestPageSizeEnum[keyof typeof GetEthTokenTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthTokensRequest
 */
export interface GetEthTokensRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetEthTokensRequest
     */
    'collection_address': string;
    /**
     * A list of token ids.
     * @type {Array<string>}
     * @memberof GetEthTokensRequest
     */
    'token_id'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthTokensRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthTokensRequest
     */
    'page_size'?: GetEthTokensRequestPageSizeEnum;
}

export const GetEthTokensRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthTokensRequestPageSizeEnum = typeof GetEthTokensRequestPageSizeEnum[keyof typeof GetEthTokensRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthWalletLabelsRequest
 */
export interface GetEthWalletLabelsRequest {
    /**
     * The EVM compatible wallet address
     * @type {string}
     * @memberof GetEthWalletLabelsRequest
     */
    'wallet_address': string;
}
/**
 * 
 * @export
 * @interface GetEthWalletNFTsRequest
 */
export interface GetEthWalletNFTsRequest {
    /**
     * The wallet address to search.
     * @type {string}
     * @memberof GetEthWalletNFTsRequest
     */
    'wallet_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthWalletNFTsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthWalletNFTsRequest
     */
    'page_size'?: GetEthWalletNFTsRequestPageSizeEnum;
}

export const GetEthWalletNFTsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthWalletNFTsRequestPageSizeEnum = typeof GetEthWalletNFTsRequestPageSizeEnum[keyof typeof GetEthWalletNFTsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthWalletTransactionsRequest
 */
export interface GetEthWalletTransactionsRequest {
    /**
     * The wallet address to search.
     * @type {string}
     * @memberof GetEthWalletTransactionsRequest
     */
    'wallet_address'?: string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthWalletTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthWalletTransactionsRequest
     */
    'page_size'?: GetEthWalletTransactionsRequestPageSizeEnum;
}

export const GetEthWalletTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthWalletTransactionsRequestPageSizeEnum = typeof GetEthWalletTransactionsRequestPageSizeEnum[keyof typeof GetEthWalletTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetEthWashTradeRequest
 */
export interface GetEthWashTradeRequest {
    /**
     * The transaction hash to valildate.
     * @type {string}
     * @memberof GetEthWashTradeRequest
     */
    'transaction_hash': string;
}
/**
 * 
 * @export
 * @interface GetEthWashTransactionsRequest
 */
export interface GetEthWashTransactionsRequest {
    /**
     * The collection address to search.
     * @type {string}
     * @memberof GetEthWashTransactionsRequest
     */
    'collection_address': string;
    /**
     * An optional list of token ids.
     * @type {Array<string>}
     * @memberof GetEthWashTransactionsRequest
     */
    'token_id'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetEthWashTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetEthWashTransactionsRequest
     */
    'page_size'?: GetEthWashTransactionsRequestPageSizeEnum;
}

export const GetEthWashTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetEthWashTransactionsRequestPageSizeEnum = typeof GetEthWashTransactionsRequestPageSizeEnum[keyof typeof GetEthWashTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionForecastsRequest
 */
export interface GetPolCollectionForecastsRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'collection_address': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetPolCollectionForecastsRequest
     */
    'percentiles'?: Array<number>;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. `arc` for ARCH
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'voltype'?: GetPolCollectionForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetPolCollectionForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for.
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'dist'?: GetPolCollectionForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to true, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetPolCollectionForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetPolCollectionForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolCollectionForecastsRequest
     */
    'rept_curr'?: GetPolCollectionForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCollectionForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetEthCollectionForecastsRequestArchParams}
     * @memberof GetPolCollectionForecastsRequest
     */
    'arch_params'?: GetEthCollectionForecastsRequestArchParams;
}

export const GetPolCollectionForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetPolCollectionForecastsRequestVoltypeEnum = typeof GetPolCollectionForecastsRequestVoltypeEnum[keyof typeof GetPolCollectionForecastsRequestVoltypeEnum];
export const GetPolCollectionForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetPolCollectionForecastsRequestDistEnum = typeof GetPolCollectionForecastsRequestDistEnum[keyof typeof GetPolCollectionForecastsRequestDistEnum];
export const GetPolCollectionForecastsRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolCollectionForecastsRequestReptCurrEnum = typeof GetPolCollectionForecastsRequestReptCurrEnum[keyof typeof GetPolCollectionForecastsRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionOwnersRequest
 */
export interface GetPolCollectionOwnersRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetPolCollectionOwnersRequest
     */
    'collection_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolCollectionOwnersRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolCollectionOwnersRequest
     */
    'page_size'?: GetPolCollectionOwnersRequestPageSizeEnum;
}

export const GetPolCollectionOwnersRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolCollectionOwnersRequestPageSizeEnum = typeof GetPolCollectionOwnersRequestPageSizeEnum[keyof typeof GetPolCollectionOwnersRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionPriceDiffRequest
 */
export interface GetPolCollectionPriceDiffRequest {
    /**
     * The Polygon contract address to identify the collection.
     * @type {string}
     * @memberof GetPolCollectionPriceDiffRequest
     */
    'collection_address': string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionPriceDiffRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionPriceDiffRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCollectionPriceDiffRequest
     */
    'exclude_wash'?: boolean;
}
/**
 * 
 * @export
 * @interface GetPolCollectionSalesOHLCRequest
 */
export interface GetPolCollectionSalesOHLCRequest {
    /**
     * The Polygon contract address to identify the collection.
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'collection_address': string;
    /**
     * The interval at which to return OHLC, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'frequency'?: string;
    /**
     * An attribute of the NFT to group results by.
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'group_by'?: string;
    /**
     * If \'true\', response dicts contain OHLCV
     * @type {boolean}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'volume'?: boolean;
    /**
     * If \'true\', append number of trades to OHLC(V)
     * @type {boolean}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'n_trades'?: boolean;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'rept_curr'?: GetPolCollectionSalesOHLCRequestReptCurrEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCollectionSalesOHLCRequest
     */
    'exclude_wash'?: boolean;
}

export const GetPolCollectionSalesOHLCRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolCollectionSalesOHLCRequestReptCurrEnum = typeof GetPolCollectionSalesOHLCRequestReptCurrEnum[keyof typeof GetPolCollectionSalesOHLCRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionSummaryRequest
 */
export interface GetPolCollectionSummaryRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetPolCollectionSummaryRequest
     */
    'collection_address': string;
    /**
     * An attribute of the NFT.
     * @type {string}
     * @memberof GetPolCollectionSummaryRequest
     */
    'group_by'?: string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCollectionSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolCollectionSummaryRequest
     */
    'rept_curr'?: GetPolCollectionSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCollectionSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetPolCollectionSummaryRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolCollectionSummaryRequestReptCurrEnum = typeof GetPolCollectionSummaryRequestReptCurrEnum[keyof typeof GetPolCollectionSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionTraitsRequest
 */
export interface GetPolCollectionTraitsRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetPolCollectionTraitsRequest
     */
    'collection_address'?: string;
}
/**
 * 
 * @export
 * @interface GetPolCollectionTransactionsRequest
 */
export interface GetPolCollectionTransactionsRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'collection_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'page_size'?: GetPolCollectionTransactionsRequestPageSizeEnum;
    /**
     * The oldest block number to return.
     * @type {number}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'start_block_number'?: number;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetPolCollectionTransactionsRequest
     */
    'end_date'?: string;
}

export const GetPolCollectionTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolCollectionTransactionsRequestPageSizeEnum = typeof GetPolCollectionTransactionsRequestPageSizeEnum[keyof typeof GetPolCollectionTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolCollectionsRequest
 */
export interface GetPolCollectionsRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolCollectionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolCollectionsRequest
     */
    'page_size'?: GetPolCollectionsRequestPageSizeEnum;
    /**
     * The name of the collection searched.
     * @type {string}
     * @memberof GetPolCollectionsRequest
     */
    'collection_name'?: string;
    /**
     * Only return collections that have traded.
     * @type {boolean}
     * @memberof GetPolCollectionsRequest
     */
    'traded'?: boolean;
    /**
     * Only return collections recorded after this day [YYYY-MM-DD]
     * @type {string}
     * @memberof GetPolCollectionsRequest
     */
    'created_after'?: string;
    /**
     * The value to sort by. Defaults to created_at
     * @type {string}
     * @memberof GetPolCollectionsRequest
     */
    'sort_by'?: GetPolCollectionsRequestSortByEnum;
}

export const GetPolCollectionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolCollectionsRequestPageSizeEnum = typeof GetPolCollectionsRequestPageSizeEnum[keyof typeof GetPolCollectionsRequestPageSizeEnum];
export const GetPolCollectionsRequestSortByEnum = {
    CreatedAt: 'created_at',
    CollectionName: 'collection_name'
} as const;

export type GetPolCollectionsRequestSortByEnum = typeof GetPolCollectionsRequestSortByEnum[keyof typeof GetPolCollectionsRequestSortByEnum];

/**
 * 
 * @export
 * @interface GetPolCustomCollectionRiskRequest
 */
export interface GetPolCustomCollectionRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'collection_address': string;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'percentiles'?: Array<number>;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'dist'?: GetPolCustomCollectionRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'end_date'?: string;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'rept_curr'?: GetPolCustomCollectionRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetPolCustomCollectionRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetPolCustomCollectionRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetPolCustomCollectionRiskRequestDistEnum = typeof GetPolCustomCollectionRiskRequestDistEnum[keyof typeof GetPolCustomCollectionRiskRequestDistEnum];
export const GetPolCustomCollectionRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolCustomCollectionRiskRequestReptCurrEnum = typeof GetPolCustomCollectionRiskRequestReptCurrEnum[keyof typeof GetPolCustomCollectionRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolCustomTokenRiskRequest
 */
export interface GetPolCustomTokenRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'token_id': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'holding_period': string;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'dist'?: GetPolCustomTokenRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'end_date'?: string;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'rept_curr'?: GetPolCustomTokenRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetPolCustomTokenRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetPolCustomTokenRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetPolCustomTokenRiskRequestDistEnum = typeof GetPolCustomTokenRiskRequestDistEnum[keyof typeof GetPolCustomTokenRiskRequestDistEnum];
export const GetPolCustomTokenRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolCustomTokenRiskRequestReptCurrEnum = typeof GetPolCustomTokenRiskRequestReptCurrEnum[keyof typeof GetPolCustomTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolDefaultCollectionRiskRequest
 */
export interface GetPolDefaultCollectionRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolDefaultCollectionRiskRequest
     */
    'collection_address': string;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetPolDefaultCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolDefaultCollectionRiskRequest
     */
    'rept_curr'?: GetPolDefaultCollectionRiskRequestReptCurrEnum;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetPolDefaultCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetPolDefaultCollectionRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetPolDefaultCollectionRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolDefaultCollectionRiskRequestReptCurrEnum = typeof GetPolDefaultCollectionRiskRequestReptCurrEnum[keyof typeof GetPolDefaultCollectionRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolDefaultTokenRiskRequest
 */
export interface GetPolDefaultTokenRiskRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolDefaultTokenRiskRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetPolDefaultTokenRiskRequest
     */
    'token_id': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetPolDefaultTokenRiskRequest
     */
    'holding_period': string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolDefaultTokenRiskRequest
     */
    'rept_curr'?: GetPolDefaultTokenRiskRequestReptCurrEnum;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetPolDefaultTokenRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetPolDefaultTokenRiskRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolDefaultTokenRiskRequestReptCurrEnum = typeof GetPolDefaultTokenRiskRequestReptCurrEnum[keyof typeof GetPolDefaultTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolHistoricalTransactionsRequest
 */
export interface GetPolHistoricalTransactionsRequest {
    /**
     * The contract address of the collection.
     * @type {string}
     * @memberof GetPolHistoricalTransactionsRequest
     */
    'collection_address': string;
    /**
     * The id for the token.
     * @type {string}
     * @memberof GetPolHistoricalTransactionsRequest
     */
    'token_id'?: string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolHistoricalTransactionsRequest
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface GetPolMarketplaceDataRequest
 */
export interface GetPolMarketplaceDataRequest {
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetPolMarketplaceDataRequest
     */
    'collection_address': Array<string>;
}
/**
 * 
 * @export
 * @interface GetPolMarketplaceFloorPriceRequest
 */
export interface GetPolMarketplaceFloorPriceRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolMarketplaceFloorPriceRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolMarketplaceFloorPriceRequest
     */
    'page_size'?: GetPolMarketplaceFloorPriceRequestPageSizeEnum;
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetPolMarketplaceFloorPriceRequest
     */
    'collection_address'?: Array<string>;
}

export const GetPolMarketplaceFloorPriceRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolMarketplaceFloorPriceRequestPageSizeEnum = typeof GetPolMarketplaceFloorPriceRequestPageSizeEnum[keyof typeof GetPolMarketplaceFloorPriceRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolRarityRequest
 */
export interface GetPolRarityRequest {
    /**
     * The Polygon contract address to identify the collection.
     * @type {string}
     * @memberof GetPolRarityRequest
     */
    'collection_address': string;
    /**
     * Dict containing trait keys and weight values.
     * @type {object}
     * @memberof GetPolRarityRequest
     */
    'weights'?: object;
    /**
     * An array of token ids.
     * @type {Array<string>}
     * @memberof GetPolRarityRequest
     */
    'token_id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetPolTokenAppraisalRequest
 */
export interface GetPolTokenAppraisalRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolTokenAppraisalRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetPolTokenAppraisalRequest
     */
    'token_id': Array<string>;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolTokenAppraisalRequest
     */
    'rept_curr'?: GetPolTokenAppraisalRequestReptCurrEnum;
    /**
     * The interval at which to calculate intermediate results and forecasts.
     * @type {string}
     * @memberof GetPolTokenAppraisalRequest
     */
    'frequency'?: string;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out). Defaults to zero which only returns nowcasts.
     * @type {number}
     * @memberof GetPolTokenAppraisalRequest
     */
    'horizon'?: number;
    /**
     * The significance level for the liquidation estimate, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetPolTokenAppraisalRequest
     */
    'alpha'?: number;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolTokenAppraisalRequest
     */
    'exclude_wash'?: boolean;
}

export const GetPolTokenAppraisalRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolTokenAppraisalRequestReptCurrEnum = typeof GetPolTokenAppraisalRequestReptCurrEnum[keyof typeof GetPolTokenAppraisalRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolTokenForecastsRequest
 */
export interface GetPolTokenForecastsRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'collection_address': string;
    /**
     * The id(s) for the token(s).
     * @type {Array<string>}
     * @memberof GetPolTokenForecastsRequest
     */
    'token_id': Array<string>;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. `arc` for ARCH
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'voltype'?: GetPolTokenForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetPolTokenForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for.
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'dist'?: GetPolTokenForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to True, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetPolTokenForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetPolTokenForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolTokenForecastsRequest
     */
    'rept_curr'?: GetPolTokenForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolTokenForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetEthCollectionForecastsRequestArchParams}
     * @memberof GetPolTokenForecastsRequest
     */
    'arch_params'?: GetEthCollectionForecastsRequestArchParams;
}

export const GetPolTokenForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetPolTokenForecastsRequestVoltypeEnum = typeof GetPolTokenForecastsRequestVoltypeEnum[keyof typeof GetPolTokenForecastsRequestVoltypeEnum];
export const GetPolTokenForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetPolTokenForecastsRequestDistEnum = typeof GetPolTokenForecastsRequestDistEnum[keyof typeof GetPolTokenForecastsRequestDistEnum];
export const GetPolTokenForecastsRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolTokenForecastsRequestReptCurrEnum = typeof GetPolTokenForecastsRequestReptCurrEnum[keyof typeof GetPolTokenForecastsRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolTokenSummaryRequest
 */
export interface GetPolTokenSummaryRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolTokenSummaryRequest
     */
    'collection_address': string;
    /**
     * The id for the token.
     * @type {Array<string>}
     * @memberof GetPolTokenSummaryRequest
     */
    'token_id': Array<string>;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetPolTokenSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetPolTokenSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetPolTokenSummaryRequest
     */
    'rept_curr'?: GetPolTokenSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetPolTokenSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetPolTokenSummaryRequestReptCurrEnum = {
    Eth: 'eth',
    Usd: 'usd',
    Matic: 'matic'
} as const;

export type GetPolTokenSummaryRequestReptCurrEnum = typeof GetPolTokenSummaryRequestReptCurrEnum[keyof typeof GetPolTokenSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetPolTokenTransactionsRequest
 */
export interface GetPolTokenTransactionsRequest {
    /**
     * The contract address the token belongs to.
     * @type {string}
     * @memberof GetPolTokenTransactionsRequest
     */
    'collection_address': string;
    /**
     * The token id.
     * @type {string}
     * @memberof GetPolTokenTransactionsRequest
     */
    'token_id': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolTokenTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolTokenTransactionsRequest
     */
    'page_size'?: GetPolTokenTransactionsRequestPageSizeEnum;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetPolTokenTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The oldest block number to return.
     * @type {number}
     * @memberof GetPolTokenTransactionsRequest
     */
    'start_block_number'?: number;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetPolTokenTransactionsRequest
     */
    'end_date'?: string;
}

export const GetPolTokenTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolTokenTransactionsRequestPageSizeEnum = typeof GetPolTokenTransactionsRequestPageSizeEnum[keyof typeof GetPolTokenTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolTokensRequest
 */
export interface GetPolTokensRequest {
    /**
     * The contract address of the token collection.
     * @type {string}
     * @memberof GetPolTokensRequest
     */
    'collection_address': string;
    /**
     * A list of token ids.
     * @type {Array<string>}
     * @memberof GetPolTokensRequest
     */
    'token_id'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolTokensRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolTokensRequest
     */
    'page_size'?: GetPolTokensRequestPageSizeEnum;
}

export const GetPolTokensRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolTokensRequestPageSizeEnum = typeof GetPolTokensRequestPageSizeEnum[keyof typeof GetPolTokensRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolWalletNFTsRequest
 */
export interface GetPolWalletNFTsRequest {
    /**
     * The wallet address to search.
     * @type {string}
     * @memberof GetPolWalletNFTsRequest
     */
    'wallet_address': string;
}
/**
 * 
 * @export
 * @interface GetPolWalletTransactionsRequest
 */
export interface GetPolWalletTransactionsRequest {
    /**
     * The wallet address to search.
     * @type {string}
     * @memberof GetPolWalletTransactionsRequest
     */
    'wallet_address'?: string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolWalletTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolWalletTransactionsRequest
     */
    'page_size'?: GetPolWalletTransactionsRequestPageSizeEnum;
}

export const GetPolWalletTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolWalletTransactionsRequestPageSizeEnum = typeof GetPolWalletTransactionsRequestPageSizeEnum[keyof typeof GetPolWalletTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetPolWashTradeRequest
 */
export interface GetPolWashTradeRequest {
    /**
     * The transaction hash to valildate.
     * @type {string}
     * @memberof GetPolWashTradeRequest
     */
    'transaction_hash': string;
}
/**
 * 
 * @export
 * @interface GetPolWashTransactionsRequest
 */
export interface GetPolWashTransactionsRequest {
    /**
     * The collection address to search.
     * @type {string}
     * @memberof GetPolWashTransactionsRequest
     */
    'collection_address': string;
    /**
     * An optional list of token ids.
     * @type {Array<string>}
     * @memberof GetPolWashTransactionsRequest
     */
    'token_id'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetPolWashTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetPolWashTransactionsRequest
     */
    'page_size'?: GetPolWashTransactionsRequestPageSizeEnum;
}

export const GetPolWashTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetPolWashTransactionsRequestPageSizeEnum = typeof GetPolWashTransactionsRequestPageSizeEnum[keyof typeof GetPolWashTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSknMarketplaceDataRequest
 */
export interface GetSknMarketplaceDataRequest {
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetSknMarketplaceDataRequest
     */
    'collection_address': Array<string>;
}
/**
 * 
 * @export
 * @interface GetSknMarketplaceFloorPriceRequest
 */
export interface GetSknMarketplaceFloorPriceRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSknMarketplaceFloorPriceRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSknMarketplaceFloorPriceRequest
     */
    'page_size'?: GetSknMarketplaceFloorPriceRequestPageSizeEnum;
    /**
     * Array of collection addresses
     * @type {Array<string>}
     * @memberof GetSknMarketplaceFloorPriceRequest
     */
    'collection_address'?: Array<string>;
}

export const GetSknMarketplaceFloorPriceRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSknMarketplaceFloorPriceRequestPageSizeEnum = typeof GetSknMarketplaceFloorPriceRequestPageSizeEnum[keyof typeof GetSknMarketplaceFloorPriceRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolAccountNFTsRequest
 */
export interface GetSolAccountNFTsRequest {
    /**
     * The account address to query.
     * @type {string}
     * @memberof GetSolAccountNFTsRequest
     */
    'account_address': string;
}
/**
 * 
 * @export
 * @interface GetSolCollectionForecastsRequest
 */
export interface GetSolCollectionForecastsRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'collection_tag': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetSolCollectionForecastsRequest
     */
    'percentiles'?: Array<number>;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. \'arc\' for ARCH
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'voltype'?: GetSolCollectionForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetSolCollectionForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'dist'?: GetSolCollectionForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to True, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetSolCollectionForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetSolCollectionForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolCollectionForecastsRequest
     */
    'rept_curr'?: GetSolCollectionForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCollectionForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetSolCollectionForecastsRequestArchParams}
     * @memberof GetSolCollectionForecastsRequest
     */
    'arch_params'?: GetSolCollectionForecastsRequestArchParams;
}

export const GetSolCollectionForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetSolCollectionForecastsRequestVoltypeEnum = typeof GetSolCollectionForecastsRequestVoltypeEnum[keyof typeof GetSolCollectionForecastsRequestVoltypeEnum];
export const GetSolCollectionForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolCollectionForecastsRequestDistEnum = typeof GetSolCollectionForecastsRequestDistEnum[keyof typeof GetSolCollectionForecastsRequestDistEnum];
export const GetSolCollectionForecastsRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolCollectionForecastsRequestReptCurrEnum = typeof GetSolCollectionForecastsRequestReptCurrEnum[keyof typeof GetSolCollectionForecastsRequestReptCurrEnum];

/**
 * JSON containing options for the ARCH family model
 * @export
 * @interface GetSolCollectionForecastsRequestArchParams
 */
export interface GetSolCollectionForecastsRequestArchParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... . 
     * @type {string}
     * @memberof GetSolCollectionForecastsRequestArchParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetSolCollectionForecastsRequestArchParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetSolCollectionForecastsRequestArchParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {number}
     * @memberof GetSolCollectionForecastsRequestArchParams
     */
    'p'?: number;
    /**
     * Return distribution assumed
     * @type {string}
     * @memberof GetSolCollectionForecastsRequestArchParams
     */
    'dist'?: GetSolCollectionForecastsRequestArchParamsDistEnum;
}

export const GetSolCollectionForecastsRequestArchParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolCollectionForecastsRequestArchParamsDistEnum = typeof GetSolCollectionForecastsRequestArchParamsDistEnum[keyof typeof GetSolCollectionForecastsRequestArchParamsDistEnum];

/**
 * 
 * @export
 * @interface GetSolCollectionPriceDiffRequest
 */
export interface GetSolCollectionPriceDiffRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolCollectionPriceDiffRequest
     */
    'collection_tag': string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionPriceDiffRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionPriceDiffRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCollectionPriceDiffRequest
     */
    'exclude_wash'?: boolean;
}
/**
 * 
 * @export
 * @interface GetSolCollectionSalesOHLCRequest
 */
export interface GetSolCollectionSalesOHLCRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'collection_tag': string;
    /**
     * The interval at which to return OHLC, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'frequency'?: string;
    /**
     * An attribute of the NFT to group results by.
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'group_by'?: string;
    /**
     * If \'true\', response dicts contain OHLCV
     * @type {boolean}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'volume'?: boolean;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'rept_curr'?: GetSolCollectionSalesOHLCRequestReptCurrEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'end_date'?: string;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCollectionSalesOHLCRequest
     */
    'exclude_wash'?: boolean;
}

export const GetSolCollectionSalesOHLCRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolCollectionSalesOHLCRequestReptCurrEnum = typeof GetSolCollectionSalesOHLCRequestReptCurrEnum[keyof typeof GetSolCollectionSalesOHLCRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolCollectionSummaryRequest
 */
export interface GetSolCollectionSummaryRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolCollectionSummaryRequest
     */
    'collection_tag': string;
    /**
     * An attribute of the NFT.
     * @type {string}
     * @memberof GetSolCollectionSummaryRequest
     */
    'group_by'?: string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCollectionSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolCollectionSummaryRequest
     */
    'rept_curr'?: GetSolCollectionSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCollectionSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetSolCollectionSummaryRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolCollectionSummaryRequestReptCurrEnum = typeof GetSolCollectionSummaryRequestReptCurrEnum[keyof typeof GetSolCollectionSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolCollectionTraitsRequest
 */
export interface GetSolCollectionTraitsRequest {
    /**
     * The tag of the collection.
     * @type {string}
     * @memberof GetSolCollectionTraitsRequest
     */
    'collection_tag'?: string;
}
/**
 * 
 * @export
 * @interface GetSolCollectionTransactionsRequest
 */
export interface GetSolCollectionTransactionsRequest {
    /**
     * The Gallop slug for the collection. Please see sol/getCollections endpoint.
     * @type {string}
     * @memberof GetSolCollectionTransactionsRequest
     */
    'collection_tag': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolCollectionTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolCollectionTransactionsRequest
     */
    'page_size'?: GetSolCollectionTransactionsRequestPageSizeEnum;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetSolCollectionTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetSolCollectionTransactionsRequest
     */
    'end_date'?: string;
}

export const GetSolCollectionTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolCollectionTransactionsRequestPageSizeEnum = typeof GetSolCollectionTransactionsRequestPageSizeEnum[keyof typeof GetSolCollectionTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolCollectionsRequest
 */
export interface GetSolCollectionsRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolCollectionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolCollectionsRequest
     */
    'page_size'?: GetSolCollectionsRequestPageSizeEnum;
    /**
     * The name of the collection searched.
     * @type {string}
     * @memberof GetSolCollectionsRequest
     */
    'collection_name'?: string;
}

export const GetSolCollectionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolCollectionsRequestPageSizeEnum = typeof GetSolCollectionsRequestPageSizeEnum[keyof typeof GetSolCollectionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolCustomCollectionRiskRequest
 */
export interface GetSolCustomCollectionRiskRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'collection_tag': string;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The collection percentile(s)
     * @type {Array<number>}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'percentiles'?: Array<number>;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'dist'?: GetSolCustomCollectionRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'end_date'?: string;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'rept_curr'?: GetSolCustomCollectionRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetSolCustomCollectionRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetSolCustomCollectionRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolCustomCollectionRiskRequestDistEnum = typeof GetSolCustomCollectionRiskRequestDistEnum[keyof typeof GetSolCustomCollectionRiskRequestDistEnum];
export const GetSolCustomCollectionRiskRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolCustomCollectionRiskRequestReptCurrEnum = typeof GetSolCustomCollectionRiskRequestReptCurrEnum[keyof typeof GetSolCustomCollectionRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolCustomTokenRiskRequest
 */
export interface GetSolCustomTokenRiskRequest {
    /**
     * A token mint address or list of mint addresses.
     * @type {Array<string>}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'mint_address': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. `12M`
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'holding_period': string;
    /**
     * The numerical id for the token. Provide either id or mint address.
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'token_id'?: string;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'dist'?: GetSolCustomTokenRiskRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'end_date'?: string;
    /**
     * The rate of return for an asset deemed risk free in the contemplated holding period
     * @type {number}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'risk_free_rate'?: number;
    /**
     * Whether to winsorize time series outliers prior to calculating risk
     * @type {boolean}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'wins_outliers'?: boolean;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'frequency'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'rept_curr'?: GetSolCustomTokenRiskRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'exclude_wash'?: boolean;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'drawdown'?: boolean;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestArcParams}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'arc_params'?: GetEthCustomCollectionRiskRequestArcParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestGarParams}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'gar_params'?: GetEthCustomCollectionRiskRequestGarParams;
    /**
     * 
     * @type {GetEthCustomCollectionRiskRequestHarParams}
     * @memberof GetSolCustomTokenRiskRequest
     */
    'har_params'?: GetEthCustomCollectionRiskRequestHarParams;
}

export const GetSolCustomTokenRiskRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolCustomTokenRiskRequestDistEnum = typeof GetSolCustomTokenRiskRequestDistEnum[keyof typeof GetSolCustomTokenRiskRequestDistEnum];
export const GetSolCustomTokenRiskRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolCustomTokenRiskRequestReptCurrEnum = typeof GetSolCustomTokenRiskRequestReptCurrEnum[keyof typeof GetSolCustomTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolDefaultCollectionRiskRequest
 */
export interface GetSolDefaultCollectionRiskRequest {
    /**
     * The Gallop tag to identify the collection.
     * @type {string}
     * @memberof GetSolDefaultCollectionRiskRequest
     */
    'collection_tag': string;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetSolDefaultCollectionRiskRequest
     */
    'holding_period': string;
    /**
     * The amount of tokens in your portfolio
     * @type {number}
     * @memberof GetSolDefaultCollectionRiskRequest
     */
    'amount'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolDefaultCollectionRiskRequest
     */
    'rept_curr'?: GetSolDefaultCollectionRiskRequestReptCurrEnum;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetSolDefaultCollectionRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetSolDefaultCollectionRiskRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolDefaultCollectionRiskRequestReptCurrEnum = typeof GetSolDefaultCollectionRiskRequestReptCurrEnum[keyof typeof GetSolDefaultCollectionRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolDefaultTokenRiskRequest
 */
export interface GetSolDefaultTokenRiskRequest {
    /**
     * A token mint address or list of mint addresses.
     * @type {Array<string>}
     * @memberof GetSolDefaultTokenRiskRequest
     */
    'mint_address': Array<string>;
    /**
     * The holding period to evaluate risk for, e.g. \'12M\'
     * @type {string}
     * @memberof GetSolDefaultTokenRiskRequest
     */
    'holding_period': string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolDefaultTokenRiskRequest
     */
    'rept_curr'?: GetSolDefaultTokenRiskRequestReptCurrEnum;
    /**
     * If true, report drawdown volatility (based on negative returns only).
     * @type {boolean}
     * @memberof GetSolDefaultTokenRiskRequest
     */
    'drawdown'?: boolean;
}

export const GetSolDefaultTokenRiskRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolDefaultTokenRiskRequestReptCurrEnum = typeof GetSolDefaultTokenRiskRequestReptCurrEnum[keyof typeof GetSolDefaultTokenRiskRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolHistoricalTransactionsRequest
 */
export interface GetSolHistoricalTransactionsRequest {
    /**
     * The Gallop slug for the collection. Please see sol/getCollections endpoint.
     * @type {string}
     * @memberof GetSolHistoricalTransactionsRequest
     */
    'collection_tag': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolHistoricalTransactionsRequest
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface GetSolMarketplaceDataRequest
 */
export interface GetSolMarketplaceDataRequest {
    /**
     * Array of Gallop collection tags
     * @type {Array<string>}
     * @memberof GetSolMarketplaceDataRequest
     */
    'collection_tag': Array<string>;
}
/**
 * 
 * @export
 * @interface GetSolMarketplaceFloorPriceRequest
 */
export interface GetSolMarketplaceFloorPriceRequest {
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolMarketplaceFloorPriceRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolMarketplaceFloorPriceRequest
     */
    'page_size'?: GetSolMarketplaceFloorPriceRequestPageSizeEnum;
    /**
     * Array of Gallop collection tags
     * @type {Array<string>}
     * @memberof GetSolMarketplaceFloorPriceRequest
     */
    'collection_tag'?: Array<string>;
}

export const GetSolMarketplaceFloorPriceRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolMarketplaceFloorPriceRequestPageSizeEnum = typeof GetSolMarketplaceFloorPriceRequestPageSizeEnum[keyof typeof GetSolMarketplaceFloorPriceRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolMarketplaceTraitDataRequest
 */
export interface GetSolMarketplaceTraitDataRequest {
    /**
     * Collection_tag
     * @type {string}
     * @memberof GetSolMarketplaceTraitDataRequest
     */
    'collection_tag': string;
}
/**
 * 
 * @export
 * @interface GetSolNFTAccountRequest
 */
export interface GetSolNFTAccountRequest {
    /**
     * The Solana token mint address.
     * @type {string}
     * @memberof GetSolNFTAccountRequest
     */
    'mint_address': string;
}
/**
 * 
 * @export
 * @interface GetSolRarityRequest
 */
export interface GetSolRarityRequest {
    /**
     * The Gallop tag for the Solana collection. Please see sol/getCollections endpoint.
     * @type {string}
     * @memberof GetSolRarityRequest
     */
    'collection_tag': string;
    /**
     * A list of token addresses.
     * @type {Array<string>}
     * @memberof GetSolRarityRequest
     */
    'mint_address'?: Array<string>;
    /**
     * Dict containing trait keys and weight values.
     * @type {object}
     * @memberof GetSolRarityRequest
     */
    'weights'?: object;
}
/**
 * 
 * @export
 * @interface GetSolTokenAppraisalRequest
 */
export interface GetSolTokenAppraisalRequest {
    /**
     * List of mint addresses of tokens to appraise
     * @type {Array<string>}
     * @memberof GetSolTokenAppraisalRequest
     */
    'mint_address': Array<string>;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolTokenAppraisalRequest
     */
    'rept_curr'?: GetSolTokenAppraisalRequestReptCurrEnum;
    /**
     * The interval at which to calculate intermediate results and forecasts.
     * @type {string}
     * @memberof GetSolTokenAppraisalRequest
     */
    'frequency'?: string;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out). Defaults to zero which only returns nowcasts.
     * @type {number}
     * @memberof GetSolTokenAppraisalRequest
     */
    'horizon'?: number;
    /**
     * The significance level for the liquidation estimate, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetSolTokenAppraisalRequest
     */
    'alpha'?: number;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolTokenAppraisalRequest
     */
    'exclude_wash'?: boolean;
}

export const GetSolTokenAppraisalRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolTokenAppraisalRequestReptCurrEnum = typeof GetSolTokenAppraisalRequestReptCurrEnum[keyof typeof GetSolTokenAppraisalRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolTokenForecastsRequest
 */
export interface GetSolTokenForecastsRequest {
    /**
     * A token mint address or list of token addresses.
     * @type {Array<string>}
     * @memberof GetSolTokenForecastsRequest
     */
    'mint_address': Array<string>;
    /**
     * The numerical id for the token. Provide either id or mint address.
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'token_id'?: string;
    /**
     * Type of statistical forecasting model to be calculated as a 3-char string, e.g. \'arc\' for ARCH
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'voltype'?: GetSolTokenForecastsRequestVoltypeEnum;
    /**
     * The forecast horizon (i.e. the number of periods to forecast out)
     * @type {number}
     * @memberof GetSolTokenForecastsRequest
     */
    'horizon'?: number;
    /**
     * The interval at which to calculate returns to base the forecasts upon, e.g. `1D` for daily, `1M` for monthly etc.
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'frequency'?: string;
    /**
     * The distribution assumed to calculate parametric risk for
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'dist'?: GetSolTokenForecastsRequestDistEnum;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'end_date'?: string;
    /**
     * Set to True, returns confidencve intervals at alpha significance for price on top of forecasts for returns and volatilities
     * @type {boolean}
     * @memberof GetSolTokenForecastsRequest
     */
    'return_price_forecasts'?: boolean;
    /**
     * The significance level, e.g. 0.05 for 95% confidence
     * @type {number}
     * @memberof GetSolTokenForecastsRequest
     */
    'alpha'?: number;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolTokenForecastsRequest
     */
    'rept_curr'?: GetSolTokenForecastsRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolTokenForecastsRequest
     */
    'exclude_wash'?: boolean;
    /**
     * 
     * @type {GetSolTokenForecastsRequestArchParams}
     * @memberof GetSolTokenForecastsRequest
     */
    'arch_params'?: GetSolTokenForecastsRequestArchParams;
}

export const GetSolTokenForecastsRequestVoltypeEnum = {
    Arc: 'arc',
    Gar: 'gar',
    Har: 'har'
} as const;

export type GetSolTokenForecastsRequestVoltypeEnum = typeof GetSolTokenForecastsRequestVoltypeEnum[keyof typeof GetSolTokenForecastsRequestVoltypeEnum];
export const GetSolTokenForecastsRequestDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolTokenForecastsRequestDistEnum = typeof GetSolTokenForecastsRequestDistEnum[keyof typeof GetSolTokenForecastsRequestDistEnum];
export const GetSolTokenForecastsRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolTokenForecastsRequestReptCurrEnum = typeof GetSolTokenForecastsRequestReptCurrEnum[keyof typeof GetSolTokenForecastsRequestReptCurrEnum];

/**
 * JSON containing options for the ARCH family model
 * @export
 * @interface GetSolTokenForecastsRequestArchParams
 */
export interface GetSolTokenForecastsRequestArchParams {
    /**
     * Estimator for the location model of the time series, e.g: `Zero`, `Constant`, `ARX`, ... . 
     * @type {string}
     * @memberof GetSolTokenForecastsRequestArchParams
     */
    'mean'?: string;
    /**
     * Number of time time period lags considered. Note that the time period is set by the `frequency` parameter, so a value of 2 will assume 2-day lags if `frequency==\'1D\'`.
     * @type {number}
     * @memberof GetSolTokenForecastsRequestArchParams
     */
    'lags'?: number;
    /**
     * Estimator used for the volatility process of the time series, e.g: `Constant`, `ARCH`, `GARCH`, ... 
     * @type {string}
     * @memberof GetSolTokenForecastsRequestArchParams
     */
    'vol'?: string;
    /**
     * Order of the symmetric innovation(s).
     * @type {number}
     * @memberof GetSolTokenForecastsRequestArchParams
     */
    'p'?: number;
    /**
     * Return distribution assumed.
     * @type {string}
     * @memberof GetSolTokenForecastsRequestArchParams
     */
    'dist'?: GetSolTokenForecastsRequestArchParamsDistEnum;
}

export const GetSolTokenForecastsRequestArchParamsDistEnum = {
    Norm: 'norm',
    T: 't'
} as const;

export type GetSolTokenForecastsRequestArchParamsDistEnum = typeof GetSolTokenForecastsRequestArchParamsDistEnum[keyof typeof GetSolTokenForecastsRequestArchParamsDistEnum];

/**
 * 
 * @export
 * @interface GetSolTokenSummaryRequest
 */
export interface GetSolTokenSummaryRequest {
    /**
     * A token mint address or list of token addresses.
     * @type {Array<string>}
     * @memberof GetSolTokenSummaryRequest
     */
    'mint_address': Array<string>;
    /**
     * The numerical id for the token. Provide either id or mint address.
     * @type {string}
     * @memberof GetSolTokenSummaryRequest
     */
    'token_id'?: string;
    /**
     * The start date to pull data for calculations
     * @type {string}
     * @memberof GetSolTokenSummaryRequest
     */
    'start_date'?: string;
    /**
     * The end date to pull data for calculations
     * @type {string}
     * @memberof GetSolTokenSummaryRequest
     */
    'end_date'?: string;
    /**
     * The currency to report results in
     * @type {string}
     * @memberof GetSolTokenSummaryRequest
     */
    'rept_curr'?: GetSolTokenSummaryRequestReptCurrEnum;
    /**
     * Exclude suspected wash transactions?
     * @type {boolean}
     * @memberof GetSolTokenSummaryRequest
     */
    'exclude_wash'?: boolean;
}

export const GetSolTokenSummaryRequestReptCurrEnum = {
    Sol: 'sol',
    Usd: 'usd'
} as const;

export type GetSolTokenSummaryRequestReptCurrEnum = typeof GetSolTokenSummaryRequestReptCurrEnum[keyof typeof GetSolTokenSummaryRequestReptCurrEnum];

/**
 * 
 * @export
 * @interface GetSolTokenTransactionsRequest
 */
export interface GetSolTokenTransactionsRequest {
    /**
     * The mint address of the token.
     * @type {string}
     * @memberof GetSolTokenTransactionsRequest
     */
    'mint_address': string;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolTokenTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolTokenTransactionsRequest
     */
    'page_size'?: GetSolTokenTransactionsRequestPageSizeEnum;
    /**
     * The earliest block timestamp.
     * @type {string}
     * @memberof GetSolTokenTransactionsRequest
     */
    'start_date'?: string;
    /**
     * The latest block timestamp.
     * @type {string}
     * @memberof GetSolTokenTransactionsRequest
     */
    'end_date'?: string;
}

export const GetSolTokenTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolTokenTransactionsRequestPageSizeEnum = typeof GetSolTokenTransactionsRequestPageSizeEnum[keyof typeof GetSolTokenTransactionsRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolTokensRequest
 */
export interface GetSolTokensRequest {
    /**
     * The Gallop tag for the Solana collection. Please see sol/getCollections endpoint.
     * @type {string}
     * @memberof GetSolTokensRequest
     */
    'collection_tag': string;
    /**
     * A list of token addresses.
     * @type {Array<string>}
     * @memberof GetSolTokensRequest
     */
    'mint_address'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolTokensRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolTokensRequest
     */
    'page_size'?: GetSolTokensRequestPageSizeEnum;
}

export const GetSolTokensRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolTokensRequestPageSizeEnum = typeof GetSolTokensRequestPageSizeEnum[keyof typeof GetSolTokensRequestPageSizeEnum];

/**
 * 
 * @export
 * @interface GetSolWashTradeRequest
 */
export interface GetSolWashTradeRequest {
    /**
     * The first signature to valildate.
     * @type {string}
     * @memberof GetSolWashTradeRequest
     */
    'first_signature': string;
}
/**
 * 
 * @export
 * @interface GetSolWashTransactionsRequest
 */
export interface GetSolWashTransactionsRequest {
    /**
     * The Gallop slug for the collection. Please see sol/getCollections endpoint.
     * @type {string}
     * @memberof GetSolWashTransactionsRequest
     */
    'collection_tag': string;
    /**
     * An optional list of token addresses.
     * @type {Array<string>}
     * @memberof GetSolWashTransactionsRequest
     */
    'mint_address'?: Array<string>;
    /**
     * The pagination cursor.
     * @type {number}
     * @memberof GetSolWashTransactionsRequest
     */
    'page'?: number;
    /**
     * The number of records returned per page.
     * @type {number}
     * @memberof GetSolWashTransactionsRequest
     */
    'page_size'?: GetSolWashTransactionsRequestPageSizeEnum;
}

export const GetSolWashTransactionsRequestPageSizeEnum = {
    NUMBER_50: 50,
    NUMBER_100: 100,
    NUMBER_500: 500,
    NUMBER_1000: 1000
} as const;

export type GetSolWashTransactionsRequestPageSizeEnum = typeof GetSolWashTransactionsRequestPageSizeEnum[keyof typeof GetSolWashTransactionsRequestPageSizeEnum];


/**
 * EthereumApi - axios parameter creator
 * @export
 */
export const EthereumApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns intraday floor price for a given collection by marketplace
         * @summary Intraday Marketplace Floor Price by Collection
         * @param {GetEthCollectionFloorPriceOHLCRequest} [getEthCollectionFloorPriceOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionFloorPriceOHLC: async (getEthCollectionFloorPriceOHLCRequest?: GetEthCollectionFloorPriceOHLCRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getCollectionFloorPriceOHLC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionFloorPriceOHLCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetEthCollectionForecastsRequest} [getEthCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionForecasts: async (getEthCollectionForecastsRequest?: GetEthCollectionForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getCollectionForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns historical floor price or more extensive open / high / floor / close candlesticks for collection listings at marketplaces at a selected time interval, as well as the number of active listings, the number of unique owners and the average age of open listings
         * @summary Collection Floor Price and Listings Candlesticks
         * @param {GetEthCollectionListingsOHLCRequest} [getEthCollectionListingsOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionListingsOHLC: async (getEthCollectionListingsOHLCRequest?: GetEthCollectionListingsOHLCRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getCollectionListingsOHLC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionListingsOHLCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetEthCollectionOwnersRequest} [getEthCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionOwners: async (getEthCollectionOwnersRequest?: GetEthCollectionOwnersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getCollectionOwners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionOwnersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetEthCollectionPriceDiffRequest} [getEthCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionPriceDiff: async (getEthCollectionPriceDiffRequest?: GetEthCollectionPriceDiffRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getCollectionPriceDiff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionPriceDiffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetEthCollectionSalesOHLCRequest} [getEthCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionSalesOHLC: async (getEthCollectionSalesOHLCRequest?: GetEthCollectionSalesOHLCRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getCollectionSalesOHLC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionSalesOHLCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetEthCollectionSummaryRequest} [getEthCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionSummary: async (getEthCollectionSummaryRequest?: GetEthCollectionSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getCollectionSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetEthCollectionTransactionsRequest} [getEthCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionTransactions: async (getEthCollectionTransactionsRequest?: GetEthCollectionTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getCollectionTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetEthCollectionsRequest} [getEthCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollections: async (getEthCollectionsRequest?: GetEthCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getCollections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetEthCustomCollectionRiskRequest} [getEthCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCustomCollectionRisk: async (getEthCustomCollectionRiskRequest?: GetEthCustomCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getCustomCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCustomCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetEthCustomTokenRiskRequest} [getEthCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCustomTokenRisk: async (getEthCustomTokenRiskRequest?: GetEthCustomTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getCustomTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthCustomTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetEthDefaultCollectionRiskRequest} [getEthDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthDefaultCollectionRisk: async (getEthDefaultCollectionRiskRequest?: GetEthDefaultCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getDefaultCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthDefaultCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetEthDefaultTokenRiskRequest} [getEthDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthDefaultTokenRisk: async (getEthDefaultTokenRiskRequest?: GetEthDefaultTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getDefaultTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthDefaultTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Ethereum Name Service data for a given wallet address
         * @summary ENS Lookup
         * @param {GetEthEnsLookupRequest} [getEthEnsLookupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthEnsLookup: async (getEthEnsLookupRequest?: GetEthEnsLookupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getEnsLookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthEnsLookupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns marketplace activity for a given collection
         * @summary Marketplace Activity by Collection
         * @param {GetEthHistoricalEventsRequest} [getEthHistoricalEventsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthHistoricalEvents: async (getEthHistoricalEventsRequest?: GetEthHistoricalEventsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getHistoricalEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthHistoricalEventsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetEthHistoricalTransactionsRequest} [getEthHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthHistoricalTransactions: async (getEthHistoricalTransactionsRequest?: GetEthHistoricalTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getHistoricalTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthHistoricalTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Ethereum Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthLeaderBoard: async (getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getLeaderBoard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthLeaderBoardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary statistics for a collection by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetEthMarketplaceDataRequest} [getEthMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceData: async (getEthMarketplaceDataRequest?: GetEthMarketplaceDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getMarketplaceData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthMarketplaceDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetEthMarketplaceFloorPriceRequest} [getEthMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceFloorPrice: async (getEthMarketplaceFloorPriceRequest?: GetEthMarketplaceFloorPriceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getMarketplaceFloorPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthMarketplaceFloorPriceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetEthMarketplaceTraitDataRequest} [getEthMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceTraitData: async (getEthMarketplaceTraitDataRequest?: GetEthMarketplaceTraitDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getMarketplaceTraitData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthMarketplaceTraitDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetEthRarityRequest} [getEthRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthRarity: async (getEthRarityRequest?: GetEthRarityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getRarity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthRarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetEthTokenAppraisalRequest} [getEthTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenAppraisal: async (getEthTokenAppraisalRequest?: GetEthTokenAppraisalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getTokenAppraisal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthTokenAppraisalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetEthTokenForecastsRequest} [getEthTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenForecasts: async (getEthTokenForecastsRequest?: GetEthTokenForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getTokenForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthTokenForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetEthTokenSummaryRequest} [getEthTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenSummary: async (getEthTokenSummaryRequest?: GetEthTokenSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getTokenSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthTokenSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetEthTokenTransactionsRequest} [getEthTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenTransactions: async (getEthTokenTransactionsRequest?: GetEthTokenTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getTokenTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthTokenTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetEthTokensRequest} [getEthTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokens: async (getEthTokensRequest?: GetEthTokensRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthTokensRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletLabels: async (getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/eth/getWalletLabels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWalletLabelsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetEthWalletNFTsRequest} [getEthWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletNFTs: async (getEthWalletNFTsRequest?: GetEthWalletNFTsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getWalletNFTs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWalletNFTsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetEthWalletTransactionsRequest} [getEthWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletTransactions: async (getEthWalletTransactionsRequest?: GetEthWalletTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/eth/getWalletTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWalletTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetEthWashTradeRequest} [getEthWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWashTrade: async (getEthWashTradeRequest?: GetEthWashTradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getWashTrade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWashTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetEthWashTransactionsRequest} [getEthWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWashTransactions: async (getEthWashTransactionsRequest?: GetEthWashTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/eth/getWashTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWashTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EthereumApi - functional programming interface
 * @export
 */
export const EthereumApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EthereumApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns intraday floor price for a given collection by marketplace
         * @summary Intraday Marketplace Floor Price by Collection
         * @param {GetEthCollectionFloorPriceOHLCRequest} [getEthCollectionFloorPriceOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest?: GetEthCollectionFloorPriceOHLCRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetEthCollectionForecastsRequest} [getEthCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionForecasts(getEthCollectionForecastsRequest?: GetEthCollectionForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionForecasts(getEthCollectionForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns historical floor price or more extensive open / high / floor / close candlesticks for collection listings at marketplaces at a selected time interval, as well as the number of active listings, the number of unique owners and the average age of open listings
         * @summary Collection Floor Price and Listings Candlesticks
         * @param {GetEthCollectionListingsOHLCRequest} [getEthCollectionListingsOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest?: GetEthCollectionListingsOHLCRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetEthCollectionOwnersRequest} [getEthCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionOwners(getEthCollectionOwnersRequest?: GetEthCollectionOwnersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionOwners(getEthCollectionOwnersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetEthCollectionPriceDiffRequest} [getEthCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest?: GetEthCollectionPriceDiffRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetEthCollectionSalesOHLCRequest} [getEthCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest?: GetEthCollectionSalesOHLCRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetEthCollectionSummaryRequest} [getEthCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionSummary(getEthCollectionSummaryRequest?: GetEthCollectionSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionSummary(getEthCollectionSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetEthCollectionTransactionsRequest} [getEthCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollectionTransactions(getEthCollectionTransactionsRequest?: GetEthCollectionTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollectionTransactions(getEthCollectionTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetEthCollectionsRequest} [getEthCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCollections(getEthCollectionsRequest?: GetEthCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCollections(getEthCollectionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetEthCustomCollectionRiskRequest} [getEthCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest?: GetEthCustomCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetEthCustomTokenRiskRequest} [getEthCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthCustomTokenRisk(getEthCustomTokenRiskRequest?: GetEthCustomTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthCustomTokenRisk(getEthCustomTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetEthDefaultCollectionRiskRequest} [getEthDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest?: GetEthDefaultCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetEthDefaultTokenRiskRequest} [getEthDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest?: GetEthDefaultTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Ethereum Name Service data for a given wallet address
         * @summary ENS Lookup
         * @param {GetEthEnsLookupRequest} [getEthEnsLookupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthEnsLookup(getEthEnsLookupRequest?: GetEthEnsLookupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthEnsLookup(getEthEnsLookupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns marketplace activity for a given collection
         * @summary Marketplace Activity by Collection
         * @param {GetEthHistoricalEventsRequest} [getEthHistoricalEventsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthHistoricalEvents(getEthHistoricalEventsRequest?: GetEthHistoricalEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthHistoricalEvents(getEthHistoricalEventsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetEthHistoricalTransactionsRequest} [getEthHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthHistoricalTransactions(getEthHistoricalTransactionsRequest?: GetEthHistoricalTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthHistoricalTransactions(getEthHistoricalTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Ethereum Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthLeaderBoard(getEthLeaderBoardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary statistics for a collection by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetEthMarketplaceDataRequest} [getEthMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthMarketplaceData(getEthMarketplaceDataRequest?: GetEthMarketplaceDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthMarketplaceData(getEthMarketplaceDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetEthMarketplaceFloorPriceRequest} [getEthMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest?: GetEthMarketplaceFloorPriceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetEthMarketplaceTraitDataRequest} [getEthMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest?: GetEthMarketplaceTraitDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetEthRarityRequest} [getEthRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthRarity(getEthRarityRequest?: GetEthRarityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthRarity(getEthRarityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetEthTokenAppraisalRequest} [getEthTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthTokenAppraisal(getEthTokenAppraisalRequest?: GetEthTokenAppraisalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthTokenAppraisal(getEthTokenAppraisalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetEthTokenForecastsRequest} [getEthTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthTokenForecasts(getEthTokenForecastsRequest?: GetEthTokenForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthTokenForecasts(getEthTokenForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetEthTokenSummaryRequest} [getEthTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthTokenSummary(getEthTokenSummaryRequest?: GetEthTokenSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthTokenSummary(getEthTokenSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetEthTokenTransactionsRequest} [getEthTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthTokenTransactions(getEthTokenTransactionsRequest?: GetEthTokenTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthTokenTransactions(getEthTokenTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetEthTokensRequest} [getEthTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthTokens(getEthTokensRequest?: GetEthTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthTokens(getEthTokensRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthWalletLabels(getEthWalletLabelsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetEthWalletNFTsRequest} [getEthWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthWalletNFTs(getEthWalletNFTsRequest?: GetEthWalletNFTsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthWalletNFTs(getEthWalletNFTsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetEthWalletTransactionsRequest} [getEthWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthWalletTransactions(getEthWalletTransactionsRequest?: GetEthWalletTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthWalletTransactions(getEthWalletTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetEthWashTradeRequest} [getEthWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthWashTrade(getEthWashTradeRequest?: GetEthWashTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthWashTrade(getEthWashTradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetEthWashTransactionsRequest} [getEthWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEthWashTransactions(getEthWashTransactionsRequest?: GetEthWashTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEthWashTransactions(getEthWashTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EthereumApi - factory interface
 * @export
 */
export const EthereumApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EthereumApiFp(configuration)
    return {
        /**
         * Returns intraday floor price for a given collection by marketplace
         * @summary Intraday Marketplace Floor Price by Collection
         * @param {GetEthCollectionFloorPriceOHLCRequest} [getEthCollectionFloorPriceOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest?: GetEthCollectionFloorPriceOHLCRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetEthCollectionForecastsRequest} [getEthCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionForecasts(getEthCollectionForecastsRequest?: GetEthCollectionForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionForecasts(getEthCollectionForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns historical floor price or more extensive open / high / floor / close candlesticks for collection listings at marketplaces at a selected time interval, as well as the number of active listings, the number of unique owners and the average age of open listings
         * @summary Collection Floor Price and Listings Candlesticks
         * @param {GetEthCollectionListingsOHLCRequest} [getEthCollectionListingsOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest?: GetEthCollectionListingsOHLCRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetEthCollectionOwnersRequest} [getEthCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionOwners(getEthCollectionOwnersRequest?: GetEthCollectionOwnersRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionOwners(getEthCollectionOwnersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetEthCollectionPriceDiffRequest} [getEthCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest?: GetEthCollectionPriceDiffRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetEthCollectionSalesOHLCRequest} [getEthCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest?: GetEthCollectionSalesOHLCRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetEthCollectionSummaryRequest} [getEthCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionSummary(getEthCollectionSummaryRequest?: GetEthCollectionSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionSummary(getEthCollectionSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetEthCollectionTransactionsRequest} [getEthCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollectionTransactions(getEthCollectionTransactionsRequest?: GetEthCollectionTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollectionTransactions(getEthCollectionTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetEthCollectionsRequest} [getEthCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCollections(getEthCollectionsRequest?: GetEthCollectionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCollections(getEthCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetEthCustomCollectionRiskRequest} [getEthCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest?: GetEthCustomCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetEthCustomTokenRiskRequest} [getEthCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthCustomTokenRisk(getEthCustomTokenRiskRequest?: GetEthCustomTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthCustomTokenRisk(getEthCustomTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetEthDefaultCollectionRiskRequest} [getEthDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest?: GetEthDefaultCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetEthDefaultTokenRiskRequest} [getEthDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest?: GetEthDefaultTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Ethereum Name Service data for a given wallet address
         * @summary ENS Lookup
         * @param {GetEthEnsLookupRequest} [getEthEnsLookupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthEnsLookup(getEthEnsLookupRequest?: GetEthEnsLookupRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthEnsLookup(getEthEnsLookupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns marketplace activity for a given collection
         * @summary Marketplace Activity by Collection
         * @param {GetEthHistoricalEventsRequest} [getEthHistoricalEventsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthHistoricalEvents(getEthHistoricalEventsRequest?: GetEthHistoricalEventsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthHistoricalEvents(getEthHistoricalEventsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetEthHistoricalTransactionsRequest} [getEthHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthHistoricalTransactions(getEthHistoricalTransactionsRequest?: GetEthHistoricalTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthHistoricalTransactions(getEthHistoricalTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Ethereum Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthLeaderBoard(getEthLeaderBoardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary statistics for a collection by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetEthMarketplaceDataRequest} [getEthMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceData(getEthMarketplaceDataRequest?: GetEthMarketplaceDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthMarketplaceData(getEthMarketplaceDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetEthMarketplaceFloorPriceRequest} [getEthMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest?: GetEthMarketplaceFloorPriceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetEthMarketplaceTraitDataRequest} [getEthMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest?: GetEthMarketplaceTraitDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetEthRarityRequest} [getEthRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthRarity(getEthRarityRequest?: GetEthRarityRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthRarity(getEthRarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetEthTokenAppraisalRequest} [getEthTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenAppraisal(getEthTokenAppraisalRequest?: GetEthTokenAppraisalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthTokenAppraisal(getEthTokenAppraisalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetEthTokenForecastsRequest} [getEthTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenForecasts(getEthTokenForecastsRequest?: GetEthTokenForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthTokenForecasts(getEthTokenForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetEthTokenSummaryRequest} [getEthTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenSummary(getEthTokenSummaryRequest?: GetEthTokenSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthTokenSummary(getEthTokenSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetEthTokenTransactionsRequest} [getEthTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokenTransactions(getEthTokenTransactionsRequest?: GetEthTokenTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthTokenTransactions(getEthTokenTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetEthTokensRequest} [getEthTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthTokens(getEthTokensRequest?: GetEthTokensRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthTokens(getEthTokensRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthWalletLabels(getEthWalletLabelsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetEthWalletNFTsRequest} [getEthWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletNFTs(getEthWalletNFTsRequest?: GetEthWalletNFTsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthWalletNFTs(getEthWalletNFTsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetEthWalletTransactionsRequest} [getEthWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWalletTransactions(getEthWalletTransactionsRequest?: GetEthWalletTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthWalletTransactions(getEthWalletTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetEthWashTradeRequest} [getEthWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWashTrade(getEthWashTradeRequest?: GetEthWashTradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthWashTrade(getEthWashTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetEthWashTransactionsRequest} [getEthWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEthWashTransactions(getEthWashTransactionsRequest?: GetEthWashTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getEthWashTransactions(getEthWashTransactionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EthereumApi - object-oriented interface
 * @export
 * @class EthereumApi
 * @extends {BaseAPI}
 */
export class EthereumApi extends BaseAPI {
    /**
     * Returns intraday floor price for a given collection by marketplace
     * @summary Intraday Marketplace Floor Price by Collection
     * @param {GetEthCollectionFloorPriceOHLCRequest} [getEthCollectionFloorPriceOHLCRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest?: GetEthCollectionFloorPriceOHLCRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionFloorPriceOHLC(getEthCollectionFloorPriceOHLCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns price, return, and volatility forecast for a given collection
     * @summary Price Forecast by Collection
     * @param {GetEthCollectionForecastsRequest} [getEthCollectionForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionForecasts(getEthCollectionForecastsRequest?: GetEthCollectionForecastsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionForecasts(getEthCollectionForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns historical floor price or more extensive open / high / floor / close candlesticks for collection listings at marketplaces at a selected time interval, as well as the number of active listings, the number of unique owners and the average age of open listings
     * @summary Collection Floor Price and Listings Candlesticks
     * @param {GetEthCollectionListingsOHLCRequest} [getEthCollectionListingsOHLCRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest?: GetEthCollectionListingsOHLCRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionListingsOHLC(getEthCollectionListingsOHLCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all wallet owners for a given collection
     * @summary Wallet Owners by Collection
     * @param {GetEthCollectionOwnersRequest} [getEthCollectionOwnersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionOwners(getEthCollectionOwnersRequest?: GetEthCollectionOwnersRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionOwners(getEthCollectionOwnersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns how trait differentiates price for a given collection
     * @summary Price Differentiation by Trait
     * @param {GetEthCollectionPriceDiffRequest} [getEthCollectionPriceDiffRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest?: GetEthCollectionPriceDiffRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionPriceDiff(getEthCollectionPriceDiffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns collection sales price open, high, low, close and volume at a selected time interval
     * @summary Collection Sales Price Candlesticks
     * @param {GetEthCollectionSalesOHLCRequest} [getEthCollectionSalesOHLCRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest?: GetEthCollectionSalesOHLCRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionSalesOHLC(getEthCollectionSalesOHLCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given collection
     * @summary Summary Statistics by Collection
     * @param {GetEthCollectionSummaryRequest} [getEthCollectionSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionSummary(getEthCollectionSummaryRequest?: GetEthCollectionSummaryRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionSummary(getEthCollectionSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection
     * @summary Transactions by Collection
     * @param {GetEthCollectionTransactionsRequest} [getEthCollectionTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollectionTransactions(getEthCollectionTransactionsRequest?: GetEthCollectionTransactionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollectionTransactions(getEthCollectionTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all Gallop aggregated collections
     * @summary Aggregated Collections Supported by Gallop
     * @param {GetEthCollectionsRequest} [getEthCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCollections(getEthCollectionsRequest?: GetEthCollectionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCollections(getEthCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given collection
     * @summary Custom Volatility & Risk Metrics by Collection
     * @param {GetEthCustomCollectionRiskRequest} [getEthCustomCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest?: GetEthCustomCollectionRiskRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCustomCollectionRisk(getEthCustomCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given token
     * @summary Custom Volatility & Risk Metrics by Token
     * @param {GetEthCustomTokenRiskRequest} [getEthCustomTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthCustomTokenRisk(getEthCustomTokenRiskRequest?: GetEthCustomTokenRiskRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthCustomTokenRisk(getEthCustomTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given collection
     * @summary Default Volatility & Risk Metrics by Collection
     * @param {GetEthDefaultCollectionRiskRequest} [getEthDefaultCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest?: GetEthDefaultCollectionRiskRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthDefaultCollectionRisk(getEthDefaultCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given token
     * @summary Default Volatility & Risk Metrics by Token
     * @param {GetEthDefaultTokenRiskRequest} [getEthDefaultTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest?: GetEthDefaultTokenRiskRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthDefaultTokenRisk(getEthDefaultTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Ethereum Name Service data for a given wallet address
     * @summary ENS Lookup
     * @param {GetEthEnsLookupRequest} [getEthEnsLookupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthEnsLookup(getEthEnsLookupRequest?: GetEthEnsLookupRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthEnsLookup(getEthEnsLookupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns marketplace activity for a given collection
     * @summary Marketplace Activity by Collection
     * @param {GetEthHistoricalEventsRequest} [getEthHistoricalEventsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthHistoricalEvents(getEthHistoricalEventsRequest?: GetEthHistoricalEventsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthHistoricalEvents(getEthHistoricalEventsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection in bulk
     * @summary Historical Transactions by Collection
     * @param {GetEthHistoricalTransactionsRequest} [getEthHistoricalTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthHistoricalTransactions(getEthHistoricalTransactionsRequest?: GetEthHistoricalTransactionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthHistoricalTransactions(getEthHistoricalTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns top collections by volume transaction volume or sales count
     * @summary Ethereum Leaderboard by Collection
     * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthLeaderBoard(getEthLeaderBoardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary statistics for a collection by marketplace
     * @summary Collection Summary by Marketplace
     * @param {GetEthMarketplaceDataRequest} [getEthMarketplaceDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthMarketplaceData(getEthMarketplaceDataRequest?: GetEthMarketplaceDataRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthMarketplaceData(getEthMarketplaceDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current floor price for all collections by marketplace
     * @summary Marketplace Floor Price by Collection
     * @param {GetEthMarketplaceFloorPriceRequest} [getEthMarketplaceFloorPriceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest?: GetEthMarketplaceFloorPriceRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthMarketplaceFloorPrice(getEthMarketplaceFloorPriceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns listing statistics for a collection by trait and marketplace
     * @summary Collection Listings by Trait & Marketplace
     * @param {GetEthMarketplaceTraitDataRequest} [getEthMarketplaceTraitDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest?: GetEthMarketplaceTraitDataRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthMarketplaceTraitData(getEthMarketplaceTraitDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rarity by token for a given collection
     * @summary Token Rarity by Collection
     * @param {GetEthRarityRequest} [getEthRarityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthRarity(getEthRarityRequest?: GetEthRarityRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthRarity(getEthRarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
     * @summary Liquidation & Appraisal Estimate by Token
     * @param {GetEthTokenAppraisalRequest} [getEthTokenAppraisalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthTokenAppraisal(getEthTokenAppraisalRequest?: GetEthTokenAppraisalRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthTokenAppraisal(getEthTokenAppraisalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns price, return, and volatility forecast for a given token
     * @summary Price Forecast by Token
     * @param {GetEthTokenForecastsRequest} [getEthTokenForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthTokenForecasts(getEthTokenForecastsRequest?: GetEthTokenForecastsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthTokenForecasts(getEthTokenForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given token
     * @summary Summary Statistics by Token
     * @param {GetEthTokenSummaryRequest} [getEthTokenSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthTokenSummary(getEthTokenSummaryRequest?: GetEthTokenSummaryRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthTokenSummary(getEthTokenSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given token
     * @summary Transactions by Token
     * @param {GetEthTokenTransactionsRequest} [getEthTokenTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthTokenTransactions(getEthTokenTransactionsRequest?: GetEthTokenTransactionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthTokenTransactions(getEthTokenTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tokens for a given collection
     * @summary Tokens by Collection
     * @param {GetEthTokensRequest} [getEthTokensRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthTokens(getEthTokensRequest?: GetEthTokensRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthTokens(getEthTokensRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Classifies a wallet\'s behaviour according to its on-chain activity
     * @summary Wallet Activity Labels
     * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthWalletLabels(getEthWalletLabelsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tokens owned for a given wallet
     * @summary Tokens Owned by Wallet
     * @param {GetEthWalletNFTsRequest} [getEthWalletNFTsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthWalletNFTs(getEthWalletNFTsRequest?: GetEthWalletNFTsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthWalletNFTs(getEthWalletNFTsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all historical token transactions for a given wallet
     * @summary Historical Token Transactions by Wallet
     * @param {GetEthWalletTransactionsRequest} [getEthWalletTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthWalletTransactions(getEthWalletTransactionsRequest?: GetEthWalletTransactionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthWalletTransactions(getEthWalletTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades for a given transaction hash
     * @summary Wash Trades by Transaction
     * @param {GetEthWashTradeRequest} [getEthWashTradeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthWashTrade(getEthWashTradeRequest?: GetEthWashTradeRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthWashTrade(getEthWashTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades by token for a given collection
     * @summary Wash Trades by Collection
     * @param {GetEthWashTransactionsRequest} [getEthWashTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EthereumApi
     */
    public getEthWashTransactions(getEthWashTransactionsRequest?: GetEthWashTransactionsRequest, options?: AxiosRequestConfig) {
        return EthereumApiFp(this.configuration).getEthWashTransactions(getEthWashTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PolygonApi - axios parameter creator
 * @export
 */
export const PolygonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetPolCollectionForecastsRequest} [getPolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionForecasts: async (getPolCollectionForecastsRequest?: GetPolCollectionForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getCollectionForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetPolCollectionOwnersRequest} [getPolCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionOwners: async (getPolCollectionOwnersRequest?: GetPolCollectionOwnersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getCollectionOwners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionOwnersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetPolCollectionPriceDiffRequest} [getPolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionPriceDiff: async (getPolCollectionPriceDiffRequest?: GetPolCollectionPriceDiffRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getCollectionPriceDiff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionPriceDiffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetPolCollectionSalesOHLCRequest} [getPolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionSalesOHLC: async (getPolCollectionSalesOHLCRequest?: GetPolCollectionSalesOHLCRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getCollectionSalesOHLC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionSalesOHLCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetPolCollectionSummaryRequest} [getPolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionSummary: async (getPolCollectionSummaryRequest?: GetPolCollectionSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getCollectionSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetPolCollectionTraitsRequest} [getPolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionTraits: async (getPolCollectionTraitsRequest?: GetPolCollectionTraitsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getCollectionTraits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionTraitsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetPolCollectionTransactionsRequest} [getPolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionTransactions: async (getPolCollectionTransactionsRequest?: GetPolCollectionTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getCollectionTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetPolCollectionsRequest} [getPolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollections: async (getPolCollectionsRequest?: GetPolCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getCollections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetPolCustomCollectionRiskRequest} [getPolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCustomCollectionRisk: async (getPolCustomCollectionRiskRequest?: GetPolCustomCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getCustomCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCustomCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetPolCustomTokenRiskRequest} [getPolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCustomTokenRisk: async (getPolCustomTokenRiskRequest?: GetPolCustomTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getCustomTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolCustomTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetPolDefaultCollectionRiskRequest} [getPolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolDefaultCollectionRisk: async (getPolDefaultCollectionRiskRequest?: GetPolDefaultCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getDefaultCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolDefaultCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetPolDefaultTokenRiskRequest} [getPolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolDefaultTokenRisk: async (getPolDefaultTokenRiskRequest?: GetPolDefaultTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getDefaultTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolDefaultTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetPolHistoricalTransactionsRequest} [getPolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolHistoricalTransactions: async (getPolHistoricalTransactionsRequest?: GetPolHistoricalTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getHistoricalTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolHistoricalTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Polygon Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolLeaderBoard: async (getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getLeaderBoard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthLeaderBoardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetPolMarketplaceDataRequest} [getPolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolMarketplaceData: async (getPolMarketplaceDataRequest?: GetPolMarketplaceDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getMarketplaceData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolMarketplaceDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetPolMarketplaceFloorPriceRequest} [getPolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolMarketplaceFloorPrice: async (getPolMarketplaceFloorPriceRequest?: GetPolMarketplaceFloorPriceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getMarketplaceFloorPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolMarketplaceFloorPriceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetPolRarityRequest} [getPolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolRarity: async (getPolRarityRequest?: GetPolRarityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getRarity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolRarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetPolTokenAppraisalRequest} [getPolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenAppraisal: async (getPolTokenAppraisalRequest?: GetPolTokenAppraisalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getTokenAppraisal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolTokenAppraisalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetPolTokenForecastsRequest} [getPolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenForecasts: async (getPolTokenForecastsRequest?: GetPolTokenForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getTokenForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolTokenForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetPolTokenSummaryRequest} [getPolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenSummary: async (getPolTokenSummaryRequest?: GetPolTokenSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getTokenSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolTokenSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetPolTokenTransactionsRequest} [getPolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenTransactions: async (getPolTokenTransactionsRequest?: GetPolTokenTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getTokenTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolTokenTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetPolTokensRequest} [getPolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokens: async (getPolTokensRequest?: GetPolTokensRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolTokensRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletLabels: async (getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/pol/getWalletLabels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getEthWalletLabelsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetPolWalletNFTsRequest} [getPolWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletNFTs: async (getPolWalletNFTsRequest?: GetPolWalletNFTsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getWalletNFTs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolWalletNFTsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetPolWalletTransactionsRequest} [getPolWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletTransactions: async (getPolWalletTransactionsRequest?: GetPolWalletTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/pol/getWalletTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolWalletTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetPolWashTradeRequest} [getPolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWashTrade: async (getPolWashTradeRequest?: GetPolWashTradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getWashTrade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolWashTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetPolWashTransactionsRequest} [getPolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWashTransactions: async (getPolWashTransactionsRequest?: GetPolWashTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/pol/getWashTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPolWashTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolygonApi - functional programming interface
 * @export
 */
export const PolygonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolygonApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetPolCollectionForecastsRequest} [getPolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionForecasts(getPolCollectionForecastsRequest?: GetPolCollectionForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionForecasts(getPolCollectionForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetPolCollectionOwnersRequest} [getPolCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionOwners(getPolCollectionOwnersRequest?: GetPolCollectionOwnersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionOwners(getPolCollectionOwnersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetPolCollectionPriceDiffRequest} [getPolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest?: GetPolCollectionPriceDiffRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetPolCollectionSalesOHLCRequest} [getPolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest?: GetPolCollectionSalesOHLCRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetPolCollectionSummaryRequest} [getPolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionSummary(getPolCollectionSummaryRequest?: GetPolCollectionSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionSummary(getPolCollectionSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetPolCollectionTraitsRequest} [getPolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionTraits(getPolCollectionTraitsRequest?: GetPolCollectionTraitsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionTraits(getPolCollectionTraitsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetPolCollectionTransactionsRequest} [getPolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollectionTransactions(getPolCollectionTransactionsRequest?: GetPolCollectionTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollectionTransactions(getPolCollectionTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetPolCollectionsRequest} [getPolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCollections(getPolCollectionsRequest?: GetPolCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCollections(getPolCollectionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetPolCustomCollectionRiskRequest} [getPolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest?: GetPolCustomCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetPolCustomTokenRiskRequest} [getPolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolCustomTokenRisk(getPolCustomTokenRiskRequest?: GetPolCustomTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolCustomTokenRisk(getPolCustomTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetPolDefaultCollectionRiskRequest} [getPolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest?: GetPolDefaultCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetPolDefaultTokenRiskRequest} [getPolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest?: GetPolDefaultTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetPolHistoricalTransactionsRequest} [getPolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolHistoricalTransactions(getPolHistoricalTransactionsRequest?: GetPolHistoricalTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolHistoricalTransactions(getPolHistoricalTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Polygon Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolLeaderBoard(getEthLeaderBoardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetPolMarketplaceDataRequest} [getPolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolMarketplaceData(getPolMarketplaceDataRequest?: GetPolMarketplaceDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolMarketplaceData(getPolMarketplaceDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetPolMarketplaceFloorPriceRequest} [getPolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest?: GetPolMarketplaceFloorPriceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetPolRarityRequest} [getPolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolRarity(getPolRarityRequest?: GetPolRarityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolRarity(getPolRarityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetPolTokenAppraisalRequest} [getPolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolTokenAppraisal(getPolTokenAppraisalRequest?: GetPolTokenAppraisalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolTokenAppraisal(getPolTokenAppraisalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetPolTokenForecastsRequest} [getPolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolTokenForecasts(getPolTokenForecastsRequest?: GetPolTokenForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolTokenForecasts(getPolTokenForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetPolTokenSummaryRequest} [getPolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolTokenSummary(getPolTokenSummaryRequest?: GetPolTokenSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolTokenSummary(getPolTokenSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetPolTokenTransactionsRequest} [getPolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolTokenTransactions(getPolTokenTransactionsRequest?: GetPolTokenTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolTokenTransactions(getPolTokenTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetPolTokensRequest} [getPolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolTokens(getPolTokensRequest?: GetPolTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolTokens(getPolTokensRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolWalletLabels(getEthWalletLabelsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetPolWalletNFTsRequest} [getPolWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolWalletNFTs(getPolWalletNFTsRequest?: GetPolWalletNFTsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolWalletNFTs(getPolWalletNFTsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetPolWalletTransactionsRequest} [getPolWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolWalletTransactions(getPolWalletTransactionsRequest?: GetPolWalletTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolWalletTransactions(getPolWalletTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetPolWashTradeRequest} [getPolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolWashTrade(getPolWashTradeRequest?: GetPolWashTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolWashTrade(getPolWashTradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetPolWashTransactionsRequest} [getPolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolWashTransactions(getPolWashTransactionsRequest?: GetPolWashTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolWashTransactions(getPolWashTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolygonApi - factory interface
 * @export
 */
export const PolygonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolygonApiFp(configuration)
    return {
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetPolCollectionForecastsRequest} [getPolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionForecasts(getPolCollectionForecastsRequest?: GetPolCollectionForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionForecasts(getPolCollectionForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Collection
         * @param {GetPolCollectionOwnersRequest} [getPolCollectionOwnersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionOwners(getPolCollectionOwnersRequest?: GetPolCollectionOwnersRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionOwners(getPolCollectionOwnersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetPolCollectionPriceDiffRequest} [getPolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest?: GetPolCollectionPriceDiffRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetPolCollectionSalesOHLCRequest} [getPolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest?: GetPolCollectionSalesOHLCRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetPolCollectionSummaryRequest} [getPolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionSummary(getPolCollectionSummaryRequest?: GetPolCollectionSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionSummary(getPolCollectionSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetPolCollectionTraitsRequest} [getPolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionTraits(getPolCollectionTraitsRequest?: GetPolCollectionTraitsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionTraits(getPolCollectionTraitsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collection
         * @param {GetPolCollectionTransactionsRequest} [getPolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollectionTransactions(getPolCollectionTransactionsRequest?: GetPolCollectionTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollectionTransactions(getPolCollectionTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetPolCollectionsRequest} [getPolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCollections(getPolCollectionsRequest?: GetPolCollectionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCollections(getPolCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetPolCustomCollectionRiskRequest} [getPolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest?: GetPolCustomCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetPolCustomTokenRiskRequest} [getPolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolCustomTokenRisk(getPolCustomTokenRiskRequest?: GetPolCustomTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolCustomTokenRisk(getPolCustomTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetPolDefaultCollectionRiskRequest} [getPolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest?: GetPolDefaultCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetPolDefaultTokenRiskRequest} [getPolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest?: GetPolDefaultTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetPolHistoricalTransactionsRequest} [getPolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolHistoricalTransactions(getPolHistoricalTransactionsRequest?: GetPolHistoricalTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolHistoricalTransactions(getPolHistoricalTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns top collections by volume transaction volume or sales count
         * @summary Polygon Leaderboard by Collection
         * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolLeaderBoard(getEthLeaderBoardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetPolMarketplaceDataRequest} [getPolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolMarketplaceData(getPolMarketplaceDataRequest?: GetPolMarketplaceDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolMarketplaceData(getPolMarketplaceDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetPolMarketplaceFloorPriceRequest} [getPolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest?: GetPolMarketplaceFloorPriceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetPolRarityRequest} [getPolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolRarity(getPolRarityRequest?: GetPolRarityRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolRarity(getPolRarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetPolTokenAppraisalRequest} [getPolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenAppraisal(getPolTokenAppraisalRequest?: GetPolTokenAppraisalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolTokenAppraisal(getPolTokenAppraisalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetPolTokenForecastsRequest} [getPolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenForecasts(getPolTokenForecastsRequest?: GetPolTokenForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolTokenForecasts(getPolTokenForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetPolTokenSummaryRequest} [getPolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenSummary(getPolTokenSummaryRequest?: GetPolTokenSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolTokenSummary(getPolTokenSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetPolTokenTransactionsRequest} [getPolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokenTransactions(getPolTokenTransactionsRequest?: GetPolTokenTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolTokenTransactions(getPolTokenTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetPolTokensRequest} [getPolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolTokens(getPolTokensRequest?: GetPolTokensRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolTokens(getPolTokensRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Classifies a wallet\'s behaviour according to its on-chain activity
         * @summary Wallet Activity Labels
         * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolWalletLabels(getEthWalletLabelsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetPolWalletNFTsRequest} [getPolWalletNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletNFTs(getPolWalletNFTsRequest?: GetPolWalletNFTsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolWalletNFTs(getPolWalletNFTsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all historical token transactions for a given wallet
         * @summary Historical Token Transactions by Wallet
         * @param {GetPolWalletTransactionsRequest} [getPolWalletTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWalletTransactions(getPolWalletTransactionsRequest?: GetPolWalletTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolWalletTransactions(getPolWalletTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetPolWashTradeRequest} [getPolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWashTrade(getPolWashTradeRequest?: GetPolWashTradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolWashTrade(getPolWashTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetPolWashTransactionsRequest} [getPolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolWashTransactions(getPolWashTransactionsRequest?: GetPolWashTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getPolWashTransactions(getPolWashTransactionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolygonApi - object-oriented interface
 * @export
 * @class PolygonApi
 * @extends {BaseAPI}
 */
export class PolygonApi extends BaseAPI {
    /**
     * Returns price, return, and volatility forecast for a given collection
     * @summary Price Forecast by Collection
     * @param {GetPolCollectionForecastsRequest} [getPolCollectionForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionForecasts(getPolCollectionForecastsRequest?: GetPolCollectionForecastsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionForecasts(getPolCollectionForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all wallet owners for a given collection
     * @summary Wallet Owners by Collection
     * @param {GetPolCollectionOwnersRequest} [getPolCollectionOwnersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionOwners(getPolCollectionOwnersRequest?: GetPolCollectionOwnersRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionOwners(getPolCollectionOwnersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns how trait differentiates price for a given collection
     * @summary Price Differentiation by Trait
     * @param {GetPolCollectionPriceDiffRequest} [getPolCollectionPriceDiffRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest?: GetPolCollectionPriceDiffRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionPriceDiff(getPolCollectionPriceDiffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns collection sales price open, high, low, close and volume at a selected time interval
     * @summary Collection Sales Price Candlesticks
     * @param {GetPolCollectionSalesOHLCRequest} [getPolCollectionSalesOHLCRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest?: GetPolCollectionSalesOHLCRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionSalesOHLC(getPolCollectionSalesOHLCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given collection
     * @summary Summary Statistics by Collection
     * @param {GetPolCollectionSummaryRequest} [getPolCollectionSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionSummary(getPolCollectionSummaryRequest?: GetPolCollectionSummaryRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionSummary(getPolCollectionSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of traits for a given collection
     * @summary Traits by Collection
     * @param {GetPolCollectionTraitsRequest} [getPolCollectionTraitsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionTraits(getPolCollectionTraitsRequest?: GetPolCollectionTraitsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionTraits(getPolCollectionTraitsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection
     * @summary Transactions by Collection
     * @param {GetPolCollectionTransactionsRequest} [getPolCollectionTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollectionTransactions(getPolCollectionTransactionsRequest?: GetPolCollectionTransactionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollectionTransactions(getPolCollectionTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all Gallop aggregated collections
     * @summary Aggregated Collections Supported by Gallop
     * @param {GetPolCollectionsRequest} [getPolCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCollections(getPolCollectionsRequest?: GetPolCollectionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCollections(getPolCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given collection
     * @summary Custom Volatility & Risk Metrics by Collection
     * @param {GetPolCustomCollectionRiskRequest} [getPolCustomCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest?: GetPolCustomCollectionRiskRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCustomCollectionRisk(getPolCustomCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given token
     * @summary Custom Volatility & Risk Metrics by Token
     * @param {GetPolCustomTokenRiskRequest} [getPolCustomTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolCustomTokenRisk(getPolCustomTokenRiskRequest?: GetPolCustomTokenRiskRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolCustomTokenRisk(getPolCustomTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given collection
     * @summary Default Volatility & Risk Metrics by Collection
     * @param {GetPolDefaultCollectionRiskRequest} [getPolDefaultCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest?: GetPolDefaultCollectionRiskRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolDefaultCollectionRisk(getPolDefaultCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given token
     * @summary Default Volatility & Risk Metrics by Token
     * @param {GetPolDefaultTokenRiskRequest} [getPolDefaultTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest?: GetPolDefaultTokenRiskRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolDefaultTokenRisk(getPolDefaultTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection in bulk
     * @summary Historical Transactions by Collection
     * @param {GetPolHistoricalTransactionsRequest} [getPolHistoricalTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolHistoricalTransactions(getPolHistoricalTransactionsRequest?: GetPolHistoricalTransactionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolHistoricalTransactions(getPolHistoricalTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns top collections by volume transaction volume or sales count
     * @summary Polygon Leaderboard by Collection
     * @param {GetEthLeaderBoardRequest} [getEthLeaderBoardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolLeaderBoard(getEthLeaderBoardRequest?: GetEthLeaderBoardRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolLeaderBoard(getEthLeaderBoardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary statistics for collections by marketplace
     * @summary Collection Summary by Marketplace
     * @param {GetPolMarketplaceDataRequest} [getPolMarketplaceDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolMarketplaceData(getPolMarketplaceDataRequest?: GetPolMarketplaceDataRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolMarketplaceData(getPolMarketplaceDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current floor price for all collections by marketplace
     * @summary Marketplace Floor Price by Collection
     * @param {GetPolMarketplaceFloorPriceRequest} [getPolMarketplaceFloorPriceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest?: GetPolMarketplaceFloorPriceRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolMarketplaceFloorPrice(getPolMarketplaceFloorPriceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rarity by token for a given collection
     * @summary Token Rarity by Collection
     * @param {GetPolRarityRequest} [getPolRarityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolRarity(getPolRarityRequest?: GetPolRarityRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolRarity(getPolRarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
     * @summary Liquidation & Appraisal Estimate by Token
     * @param {GetPolTokenAppraisalRequest} [getPolTokenAppraisalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolTokenAppraisal(getPolTokenAppraisalRequest?: GetPolTokenAppraisalRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolTokenAppraisal(getPolTokenAppraisalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns price, return, and volatility forecast for a given token
     * @summary Price Forecast by Token
     * @param {GetPolTokenForecastsRequest} [getPolTokenForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolTokenForecasts(getPolTokenForecastsRequest?: GetPolTokenForecastsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolTokenForecasts(getPolTokenForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given token
     * @summary Summary Statistics by Token
     * @param {GetPolTokenSummaryRequest} [getPolTokenSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolTokenSummary(getPolTokenSummaryRequest?: GetPolTokenSummaryRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolTokenSummary(getPolTokenSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given token
     * @summary Transactions by Token
     * @param {GetPolTokenTransactionsRequest} [getPolTokenTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolTokenTransactions(getPolTokenTransactionsRequest?: GetPolTokenTransactionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolTokenTransactions(getPolTokenTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tokens for a given collection
     * @summary Tokens by Collection
     * @param {GetPolTokensRequest} [getPolTokensRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolTokens(getPolTokensRequest?: GetPolTokensRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolTokens(getPolTokensRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Classifies a wallet\'s behaviour according to its on-chain activity
     * @summary Wallet Activity Labels
     * @param {GetEthWalletLabelsRequest} [getEthWalletLabelsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolWalletLabels(getEthWalletLabelsRequest?: GetEthWalletLabelsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolWalletLabels(getEthWalletLabelsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tokens owned for a given wallet
     * @summary Tokens Owned by Wallet
     * @param {GetPolWalletNFTsRequest} [getPolWalletNFTsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolWalletNFTs(getPolWalletNFTsRequest?: GetPolWalletNFTsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolWalletNFTs(getPolWalletNFTsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all historical token transactions for a given wallet
     * @summary Historical Token Transactions by Wallet
     * @param {GetPolWalletTransactionsRequest} [getPolWalletTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolWalletTransactions(getPolWalletTransactionsRequest?: GetPolWalletTransactionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolWalletTransactions(getPolWalletTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades for a given transaction hash
     * @summary Wash Trades by Transaction
     * @param {GetPolWashTradeRequest} [getPolWashTradeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolWashTrade(getPolWashTradeRequest?: GetPolWashTradeRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolWashTrade(getPolWashTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades by token for a given collection
     * @summary Wash Trades by Collection
     * @param {GetPolWashTransactionsRequest} [getPolWashTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolygonApi
     */
    public getPolWashTransactions(getPolWashTransactionsRequest?: GetPolWashTransactionsRequest, options?: AxiosRequestConfig) {
        return PolygonApiFp(this.configuration).getPolWashTransactions(getPolWashTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SolanaApi - axios parameter creator
 * @export
 */
export const SolanaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetSolAccountNFTsRequest} [getSolAccountNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolAccountNFTs: async (getSolAccountNFTsRequest?: GetSolAccountNFTsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getAccountNFTs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolAccountNFTsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetSolCollectionForecastsRequest} [getSolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionForecasts: async (getSolCollectionForecastsRequest?: GetSolCollectionForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getCollectionForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetSolCollectionPriceDiffRequest} [getSolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionPriceDiff: async (getSolCollectionPriceDiffRequest?: GetSolCollectionPriceDiffRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getCollectionPriceDiff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionPriceDiffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetSolCollectionSalesOHLCRequest} [getSolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionSalesOHLC: async (getSolCollectionSalesOHLCRequest?: GetSolCollectionSalesOHLCRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getCollectionSalesOHLC`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionSalesOHLCRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetSolCollectionSummaryRequest} [getSolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionSummary: async (getSolCollectionSummaryRequest?: GetSolCollectionSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getCollectionSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetSolCollectionTraitsRequest} [getSolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionTraits: async (getSolCollectionTraitsRequest?: GetSolCollectionTraitsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getCollectionTraits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionTraitsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collections
         * @param {GetSolCollectionTransactionsRequest} [getSolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionTransactions: async (getSolCollectionTransactionsRequest?: GetSolCollectionTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getCollectionTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetSolCollectionsRequest} [getSolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollections: async (getSolCollectionsRequest?: GetSolCollectionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getCollections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCollectionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetSolCustomCollectionRiskRequest} [getSolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCustomCollectionRisk: async (getSolCustomCollectionRiskRequest?: GetSolCustomCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getCustomCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCustomCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetSolCustomTokenRiskRequest} [getSolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCustomTokenRisk: async (getSolCustomTokenRiskRequest?: GetSolCustomTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getCustomTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolCustomTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetSolDefaultCollectionRiskRequest} [getSolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolDefaultCollectionRisk: async (getSolDefaultCollectionRiskRequest?: GetSolDefaultCollectionRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getDefaultCollectionRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolDefaultCollectionRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetSolDefaultTokenRiskRequest} [getSolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolDefaultTokenRisk: async (getSolDefaultTokenRiskRequest?: GetSolDefaultTokenRiskRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getDefaultTokenRisk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolDefaultTokenRiskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetSolHistoricalTransactionsRequest} [getSolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolHistoricalTransactions: async (getSolHistoricalTransactionsRequest?: GetSolHistoricalTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getHistoricalTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolHistoricalTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetSolMarketplaceDataRequest} [getSolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceData: async (getSolMarketplaceDataRequest?: GetSolMarketplaceDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getMarketplaceData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolMarketplaceDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSolMarketplaceFloorPriceRequest} [getSolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceFloorPrice: async (getSolMarketplaceFloorPriceRequest?: GetSolMarketplaceFloorPriceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getMarketplaceFloorPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolMarketplaceFloorPriceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetSolMarketplaceTraitDataRequest} [getSolMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceTraitData: async (getSolMarketplaceTraitDataRequest?: GetSolMarketplaceTraitDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getMarketplaceTraitData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolMarketplaceTraitDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Token
         * @param {GetSolNFTAccountRequest} [getSolNFTAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolNFTAccount: async (getSolNFTAccountRequest?: GetSolNFTAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getNFTAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolNFTAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetSolRarityRequest} [getSolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolRarity: async (getSolRarityRequest?: GetSolRarityRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getRarity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolRarityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetSolTokenAppraisalRequest} [getSolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenAppraisal: async (getSolTokenAppraisalRequest?: GetSolTokenAppraisalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getTokenAppraisal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolTokenAppraisalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetSolTokenForecastsRequest} [getSolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenForecasts: async (getSolTokenForecastsRequest?: GetSolTokenForecastsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/insights/sol/getTokenForecasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolTokenForecastsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetSolTokenSummaryRequest} [getSolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenSummary: async (getSolTokenSummaryRequest?: GetSolTokenSummaryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getTokenSummary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolTokenSummaryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetSolTokenTransactionsRequest} [getSolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenTransactions: async (getSolTokenTransactionsRequest?: GetSolTokenTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getTokenTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolTokenTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetSolTokensRequest} [getSolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokens: async (getSolTokensRequest?: GetSolTokensRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/sol/getTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolTokensRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetSolWashTradeRequest} [getSolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolWashTrade: async (getSolWashTradeRequest?: GetSolWashTradeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getWashTrade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolWashTradeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetSolWashTransactionsRequest} [getSolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolWashTransactions: async (getSolWashTransactionsRequest?: GetSolWashTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/sol/getWashTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSolWashTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolanaApi - functional programming interface
 * @export
 */
export const SolanaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolanaApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetSolAccountNFTsRequest} [getSolAccountNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolAccountNFTs(getSolAccountNFTsRequest?: GetSolAccountNFTsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolAccountNFTs(getSolAccountNFTsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetSolCollectionForecastsRequest} [getSolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionForecasts(getSolCollectionForecastsRequest?: GetSolCollectionForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionForecasts(getSolCollectionForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetSolCollectionPriceDiffRequest} [getSolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest?: GetSolCollectionPriceDiffRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetSolCollectionSalesOHLCRequest} [getSolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest?: GetSolCollectionSalesOHLCRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetSolCollectionSummaryRequest} [getSolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionSummary(getSolCollectionSummaryRequest?: GetSolCollectionSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionSummary(getSolCollectionSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetSolCollectionTraitsRequest} [getSolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionTraits(getSolCollectionTraitsRequest?: GetSolCollectionTraitsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionTraits(getSolCollectionTraitsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collections
         * @param {GetSolCollectionTransactionsRequest} [getSolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollectionTransactions(getSolCollectionTransactionsRequest?: GetSolCollectionTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollectionTransactions(getSolCollectionTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetSolCollectionsRequest} [getSolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCollections(getSolCollectionsRequest?: GetSolCollectionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCollections(getSolCollectionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetSolCustomCollectionRiskRequest} [getSolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest?: GetSolCustomCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetSolCustomTokenRiskRequest} [getSolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolCustomTokenRisk(getSolCustomTokenRiskRequest?: GetSolCustomTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolCustomTokenRisk(getSolCustomTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetSolDefaultCollectionRiskRequest} [getSolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest?: GetSolDefaultCollectionRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetSolDefaultTokenRiskRequest} [getSolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest?: GetSolDefaultTokenRiskRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetSolHistoricalTransactionsRequest} [getSolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolHistoricalTransactions(getSolHistoricalTransactionsRequest?: GetSolHistoricalTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolHistoricalTransactions(getSolHistoricalTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetSolMarketplaceDataRequest} [getSolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolMarketplaceData(getSolMarketplaceDataRequest?: GetSolMarketplaceDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolMarketplaceData(getSolMarketplaceDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSolMarketplaceFloorPriceRequest} [getSolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest?: GetSolMarketplaceFloorPriceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetSolMarketplaceTraitDataRequest} [getSolMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest?: GetSolMarketplaceTraitDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Token
         * @param {GetSolNFTAccountRequest} [getSolNFTAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolNFTAccount(getSolNFTAccountRequest?: GetSolNFTAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolNFTAccount(getSolNFTAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetSolRarityRequest} [getSolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolRarity(getSolRarityRequest?: GetSolRarityRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolRarity(getSolRarityRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetSolTokenAppraisalRequest} [getSolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolTokenAppraisal(getSolTokenAppraisalRequest?: GetSolTokenAppraisalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolTokenAppraisal(getSolTokenAppraisalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetSolTokenForecastsRequest} [getSolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolTokenForecasts(getSolTokenForecastsRequest?: GetSolTokenForecastsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolTokenForecasts(getSolTokenForecastsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetSolTokenSummaryRequest} [getSolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolTokenSummary(getSolTokenSummaryRequest?: GetSolTokenSummaryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolTokenSummary(getSolTokenSummaryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetSolTokenTransactionsRequest} [getSolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolTokenTransactions(getSolTokenTransactionsRequest?: GetSolTokenTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolTokenTransactions(getSolTokenTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetSolTokensRequest} [getSolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolTokens(getSolTokensRequest?: GetSolTokensRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolTokens(getSolTokensRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetSolWashTradeRequest} [getSolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolWashTrade(getSolWashTradeRequest?: GetSolWashTradeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolWashTrade(getSolWashTradeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetSolWashTransactionsRequest} [getSolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolWashTransactions(getSolWashTransactionsRequest?: GetSolWashTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolWashTransactions(getSolWashTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SolanaApi - factory interface
 * @export
 */
export const SolanaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolanaApiFp(configuration)
    return {
        /**
         * Returns all tokens owned for a given wallet
         * @summary Tokens Owned by Wallet
         * @param {GetSolAccountNFTsRequest} [getSolAccountNFTsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolAccountNFTs(getSolAccountNFTsRequest?: GetSolAccountNFTsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolAccountNFTs(getSolAccountNFTsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns price, return, and volatility forecast for a given collection
         * @summary Price Forecast by Collection
         * @param {GetSolCollectionForecastsRequest} [getSolCollectionForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionForecasts(getSolCollectionForecastsRequest?: GetSolCollectionForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionForecasts(getSolCollectionForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns how trait differentiates price for a given collection
         * @summary Price Differentiation by Trait
         * @param {GetSolCollectionPriceDiffRequest} [getSolCollectionPriceDiffRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest?: GetSolCollectionPriceDiffRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns collection sales price open, high, low, close and volume at a selected time interval
         * @summary Collection Sales Price Candlesticks
         * @param {GetSolCollectionSalesOHLCRequest} [getSolCollectionSalesOHLCRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest?: GetSolCollectionSalesOHLCRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given collection
         * @summary Summary Statistics by Collection
         * @param {GetSolCollectionSummaryRequest} [getSolCollectionSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionSummary(getSolCollectionSummaryRequest?: GetSolCollectionSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionSummary(getSolCollectionSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of traits for a given collection
         * @summary Traits by Collection
         * @param {GetSolCollectionTraitsRequest} [getSolCollectionTraitsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionTraits(getSolCollectionTraitsRequest?: GetSolCollectionTraitsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionTraits(getSolCollectionTraitsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection
         * @summary Transactions by Collections
         * @param {GetSolCollectionTransactionsRequest} [getSolCollectionTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollectionTransactions(getSolCollectionTransactionsRequest?: GetSolCollectionTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollectionTransactions(getSolCollectionTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Gallop aggregated collections
         * @summary Aggregated Collections Supported by Gallop
         * @param {GetSolCollectionsRequest} [getSolCollectionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCollections(getSolCollectionsRequest?: GetSolCollectionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCollections(getSolCollectionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given collection
         * @summary Custom Volatility & Risk Metrics by Collection
         * @param {GetSolCustomCollectionRiskRequest} [getSolCustomCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest?: GetSolCustomCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of customizable volatility and risk metrics for a given token
         * @summary Custom Volatility & Risk Metrics by Token
         * @param {GetSolCustomTokenRiskRequest} [getSolCustomTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolCustomTokenRisk(getSolCustomTokenRiskRequest?: GetSolCustomTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolCustomTokenRisk(getSolCustomTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given collection
         * @summary Default Volatility & Risk Metrics by Collection
         * @param {GetSolDefaultCollectionRiskRequest} [getSolDefaultCollectionRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest?: GetSolDefaultCollectionRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary of default volatility and risk metrics for a given token
         * @summary Default Volatility & Risk Metrics by Token
         * @param {GetSolDefaultTokenRiskRequest} [getSolDefaultTokenRiskRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest?: GetSolDefaultTokenRiskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given collection in bulk
         * @summary Historical Transactions by Collection
         * @param {GetSolHistoricalTransactionsRequest} [getSolHistoricalTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolHistoricalTransactions(getSolHistoricalTransactionsRequest?: GetSolHistoricalTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolHistoricalTransactions(getSolHistoricalTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary statistics for collections by marketplace
         * @summary Collection Summary by Marketplace
         * @param {GetSolMarketplaceDataRequest} [getSolMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceData(getSolMarketplaceDataRequest?: GetSolMarketplaceDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolMarketplaceData(getSolMarketplaceDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSolMarketplaceFloorPriceRequest} [getSolMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest?: GetSolMarketplaceFloorPriceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns listing statistics for a collection by trait and marketplace
         * @summary Collection Listings by Trait & Marketplace
         * @param {GetSolMarketplaceTraitDataRequest} [getSolMarketplaceTraitDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest?: GetSolMarketplaceTraitDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all wallet owners for a given collection
         * @summary Wallet Owners by Token
         * @param {GetSolNFTAccountRequest} [getSolNFTAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolNFTAccount(getSolNFTAccountRequest?: GetSolNFTAccountRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolNFTAccount(getSolNFTAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rarity by token for a given collection
         * @summary Token Rarity by Collection
         * @param {GetSolRarityRequest} [getSolRarityRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolRarity(getSolRarityRequest?: GetSolRarityRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolRarity(getSolRarityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
         * @summary Liquidation & Appraisal Estimate by Token
         * @param {GetSolTokenAppraisalRequest} [getSolTokenAppraisalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenAppraisal(getSolTokenAppraisalRequest?: GetSolTokenAppraisalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolTokenAppraisal(getSolTokenAppraisalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns price, return, and volatility forecast for a given token
         * @summary Price Forecast by Token
         * @param {GetSolTokenForecastsRequest} [getSolTokenForecastsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenForecasts(getSolTokenForecastsRequest?: GetSolTokenForecastsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolTokenForecasts(getSolTokenForecastsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns summary analytics for a given token
         * @summary Summary Statistics by Token
         * @param {GetSolTokenSummaryRequest} [getSolTokenSummaryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenSummary(getSolTokenSummaryRequest?: GetSolTokenSummaryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolTokenSummary(getSolTokenSummaryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all transactions for a given token
         * @summary Transactions by Token
         * @param {GetSolTokenTransactionsRequest} [getSolTokenTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokenTransactions(getSolTokenTransactionsRequest?: GetSolTokenTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolTokenTransactions(getSolTokenTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all tokens for a given collection
         * @summary Tokens by Collection
         * @param {GetSolTokensRequest} [getSolTokensRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolTokens(getSolTokensRequest?: GetSolTokensRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolTokens(getSolTokensRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades for a given transaction hash
         * @summary Wash Trades by Transaction
         * @param {GetSolWashTradeRequest} [getSolWashTradeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolWashTrade(getSolWashTradeRequest?: GetSolWashTradeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolWashTrade(getSolWashTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns suspected wash trades by token for a given collection
         * @summary Wash Trades by Collection
         * @param {GetSolWashTransactionsRequest} [getSolWashTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolWashTransactions(getSolWashTransactionsRequest?: GetSolWashTransactionsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSolWashTransactions(getSolWashTransactionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolanaApi - object-oriented interface
 * @export
 * @class SolanaApi
 * @extends {BaseAPI}
 */
export class SolanaApi extends BaseAPI {
    /**
     * Returns all tokens owned for a given wallet
     * @summary Tokens Owned by Wallet
     * @param {GetSolAccountNFTsRequest} [getSolAccountNFTsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolAccountNFTs(getSolAccountNFTsRequest?: GetSolAccountNFTsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolAccountNFTs(getSolAccountNFTsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns price, return, and volatility forecast for a given collection
     * @summary Price Forecast by Collection
     * @param {GetSolCollectionForecastsRequest} [getSolCollectionForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionForecasts(getSolCollectionForecastsRequest?: GetSolCollectionForecastsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionForecasts(getSolCollectionForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns how trait differentiates price for a given collection
     * @summary Price Differentiation by Trait
     * @param {GetSolCollectionPriceDiffRequest} [getSolCollectionPriceDiffRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest?: GetSolCollectionPriceDiffRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionPriceDiff(getSolCollectionPriceDiffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns collection sales price open, high, low, close and volume at a selected time interval
     * @summary Collection Sales Price Candlesticks
     * @param {GetSolCollectionSalesOHLCRequest} [getSolCollectionSalesOHLCRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest?: GetSolCollectionSalesOHLCRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionSalesOHLC(getSolCollectionSalesOHLCRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given collection
     * @summary Summary Statistics by Collection
     * @param {GetSolCollectionSummaryRequest} [getSolCollectionSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionSummary(getSolCollectionSummaryRequest?: GetSolCollectionSummaryRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionSummary(getSolCollectionSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of traits for a given collection
     * @summary Traits by Collection
     * @param {GetSolCollectionTraitsRequest} [getSolCollectionTraitsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionTraits(getSolCollectionTraitsRequest?: GetSolCollectionTraitsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionTraits(getSolCollectionTraitsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection
     * @summary Transactions by Collections
     * @param {GetSolCollectionTransactionsRequest} [getSolCollectionTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollectionTransactions(getSolCollectionTransactionsRequest?: GetSolCollectionTransactionsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollectionTransactions(getSolCollectionTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all Gallop aggregated collections
     * @summary Aggregated Collections Supported by Gallop
     * @param {GetSolCollectionsRequest} [getSolCollectionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCollections(getSolCollectionsRequest?: GetSolCollectionsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCollections(getSolCollectionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given collection
     * @summary Custom Volatility & Risk Metrics by Collection
     * @param {GetSolCustomCollectionRiskRequest} [getSolCustomCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest?: GetSolCustomCollectionRiskRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCustomCollectionRisk(getSolCustomCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of customizable volatility and risk metrics for a given token
     * @summary Custom Volatility & Risk Metrics by Token
     * @param {GetSolCustomTokenRiskRequest} [getSolCustomTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolCustomTokenRisk(getSolCustomTokenRiskRequest?: GetSolCustomTokenRiskRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolCustomTokenRisk(getSolCustomTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given collection
     * @summary Default Volatility & Risk Metrics by Collection
     * @param {GetSolDefaultCollectionRiskRequest} [getSolDefaultCollectionRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest?: GetSolDefaultCollectionRiskRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolDefaultCollectionRisk(getSolDefaultCollectionRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary of default volatility and risk metrics for a given token
     * @summary Default Volatility & Risk Metrics by Token
     * @param {GetSolDefaultTokenRiskRequest} [getSolDefaultTokenRiskRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest?: GetSolDefaultTokenRiskRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolDefaultTokenRisk(getSolDefaultTokenRiskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given collection in bulk
     * @summary Historical Transactions by Collection
     * @param {GetSolHistoricalTransactionsRequest} [getSolHistoricalTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolHistoricalTransactions(getSolHistoricalTransactionsRequest?: GetSolHistoricalTransactionsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolHistoricalTransactions(getSolHistoricalTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary statistics for collections by marketplace
     * @summary Collection Summary by Marketplace
     * @param {GetSolMarketplaceDataRequest} [getSolMarketplaceDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolMarketplaceData(getSolMarketplaceDataRequest?: GetSolMarketplaceDataRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolMarketplaceData(getSolMarketplaceDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current floor price for all collections by marketplace
     * @summary Marketplace Floor Price by Collection
     * @param {GetSolMarketplaceFloorPriceRequest} [getSolMarketplaceFloorPriceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest?: GetSolMarketplaceFloorPriceRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolMarketplaceFloorPrice(getSolMarketplaceFloorPriceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns listing statistics for a collection by trait and marketplace
     * @summary Collection Listings by Trait & Marketplace
     * @param {GetSolMarketplaceTraitDataRequest} [getSolMarketplaceTraitDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest?: GetSolMarketplaceTraitDataRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolMarketplaceTraitData(getSolMarketplaceTraitDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all wallet owners for a given collection
     * @summary Wallet Owners by Token
     * @param {GetSolNFTAccountRequest} [getSolNFTAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolNFTAccount(getSolNFTAccountRequest?: GetSolNFTAccountRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolNFTAccount(getSolNFTAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rarity by token for a given collection
     * @summary Token Rarity by Collection
     * @param {GetSolRarityRequest} [getSolRarityRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolRarity(getSolRarityRequest?: GetSolRarityRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolRarity(getSolRarityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get estimates of appraisal and liquidation values for a set of tokens. The app returns nowcasts by default, but if provided a `horizon` and `frequency`, it will return forcasts for `horizon` periods out at interval `frequency`. The app is does not deliver individualized financial advice, but merely provides analytical estimates of token appraisal and liquidation values
     * @summary Liquidation & Appraisal Estimate by Token
     * @param {GetSolTokenAppraisalRequest} [getSolTokenAppraisalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolTokenAppraisal(getSolTokenAppraisalRequest?: GetSolTokenAppraisalRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolTokenAppraisal(getSolTokenAppraisalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns price, return, and volatility forecast for a given token
     * @summary Price Forecast by Token
     * @param {GetSolTokenForecastsRequest} [getSolTokenForecastsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolTokenForecasts(getSolTokenForecastsRequest?: GetSolTokenForecastsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolTokenForecasts(getSolTokenForecastsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns summary analytics for a given token
     * @summary Summary Statistics by Token
     * @param {GetSolTokenSummaryRequest} [getSolTokenSummaryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolTokenSummary(getSolTokenSummaryRequest?: GetSolTokenSummaryRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolTokenSummary(getSolTokenSummaryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all transactions for a given token
     * @summary Transactions by Token
     * @param {GetSolTokenTransactionsRequest} [getSolTokenTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolTokenTransactions(getSolTokenTransactionsRequest?: GetSolTokenTransactionsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolTokenTransactions(getSolTokenTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all tokens for a given collection
     * @summary Tokens by Collection
     * @param {GetSolTokensRequest} [getSolTokensRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolTokens(getSolTokensRequest?: GetSolTokensRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolTokens(getSolTokensRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades for a given transaction hash
     * @summary Wash Trades by Transaction
     * @param {GetSolWashTradeRequest} [getSolWashTradeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolWashTrade(getSolWashTradeRequest?: GetSolWashTradeRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolWashTrade(getSolWashTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns suspected wash trades by token for a given collection
     * @summary Wash Trades by Collection
     * @param {GetSolWashTransactionsRequest} [getSolWashTransactionsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolanaApi
     */
    public getSolWashTransactions(getSolWashTransactionsRequest?: GetSolWashTransactionsRequest, options?: AxiosRequestConfig) {
        return SolanaApiFp(this.configuration).getSolWashTransactions(getSolWashTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StarknetApi - axios parameter creator
 * @export
 */
export const StarknetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists marketplace data from contract address.
         * @summary Gallop Marketplace Data
         * @param {GetSknMarketplaceDataRequest} [getSknMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSknMarketplaceData: async (getSknMarketplaceDataRequest?: GetSknMarketplaceDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/skn/getMarketplaceData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSknMarketplaceDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSknMarketplaceFloorPriceRequest} [getSknMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSknMarketplaceFloorPrice: async (getSknMarketplaceFloorPriceRequest?: GetSknMarketplaceFloorPriceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/data/skn/getMarketplaceFloorPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getSknMarketplaceFloorPriceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StarknetApi - functional programming interface
 * @export
 */
export const StarknetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StarknetApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists marketplace data from contract address.
         * @summary Gallop Marketplace Data
         * @param {GetSknMarketplaceDataRequest} [getSknMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSknMarketplaceData(getSknMarketplaceDataRequest?: GetSknMarketplaceDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSknMarketplaceData(getSknMarketplaceDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSknMarketplaceFloorPriceRequest} [getSknMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest?: GetSknMarketplaceFloorPriceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StarknetApi - factory interface
 * @export
 */
export const StarknetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StarknetApiFp(configuration)
    return {
        /**
         * Lists marketplace data from contract address.
         * @summary Gallop Marketplace Data
         * @param {GetSknMarketplaceDataRequest} [getSknMarketplaceDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSknMarketplaceData(getSknMarketplaceDataRequest?: GetSknMarketplaceDataRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSknMarketplaceData(getSknMarketplaceDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current floor price for all collections by marketplace
         * @summary Marketplace Floor Price by Collection
         * @param {GetSknMarketplaceFloorPriceRequest} [getSknMarketplaceFloorPriceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest?: GetSknMarketplaceFloorPriceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StarknetApi - object-oriented interface
 * @export
 * @class StarknetApi
 * @extends {BaseAPI}
 */
export class StarknetApi extends BaseAPI {
    /**
     * Lists marketplace data from contract address.
     * @summary Gallop Marketplace Data
     * @param {GetSknMarketplaceDataRequest} [getSknMarketplaceDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarknetApi
     */
    public getSknMarketplaceData(getSknMarketplaceDataRequest?: GetSknMarketplaceDataRequest, options?: AxiosRequestConfig) {
        return StarknetApiFp(this.configuration).getSknMarketplaceData(getSknMarketplaceDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current floor price for all collections by marketplace
     * @summary Marketplace Floor Price by Collection
     * @param {GetSknMarketplaceFloorPriceRequest} [getSknMarketplaceFloorPriceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StarknetApi
     */
    public getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest?: GetSknMarketplaceFloorPriceRequest, options?: AxiosRequestConfig) {
        return StarknetApiFp(this.configuration).getSknMarketplaceFloorPrice(getSknMarketplaceFloorPriceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


